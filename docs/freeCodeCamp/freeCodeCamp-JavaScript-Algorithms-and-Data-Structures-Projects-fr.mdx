---
id: freeCodeCamp-JavaScript-Algorithms-and-Data-Structures-Projects-fr
title: Projets d'algorithmes JavaScript et de structures de données
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Introduction aux projets d'algorithmes JavaScript et de structures de données

[JavaScript Algorithms and Data Structures Projects | freeCodeCamp.org](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/javascript-algorithms-and-data-structures-projects/)

Il est temps de mettre vos nouvelles compétences en JavaScript au travail ! Ces défis seront similaires aux défis de script d'algorithme, mais plus difficiles. Cela vous permettra de prouver tout ce que vous avez appris.

Dans cette section, vous allez créer les petits programmes JavaScript suivants :

- Vérificateur de Palindrome
- Convertisseur de chiffres romains
- Chiffre de Césars
- Validateur de numéro de téléphone
- Caisse enregistreuse

Amusez-vous et n'oubliez pas d'utiliser la méthode Lire-Rechercher-Demander ([Read-Search-Ask](https://forum.freecodecamp.org/t/how-to-get-help-when-you-are-stuck-coding/19514)) si vous êtes bloqué.

Bonne chance !

-----



## 1. Vérificateur de Palindrome

[Learn JavaScript Algorithms and Data Structures Projects: Palindrome Checker | freeCodeCamp.org](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/javascript-algorithms-and-data-structures-projects/palindrome-checker)

:::info instructions
Renvoie `true` si la chaîne donnée est un palindrome. Sinon, retournez `false`.<br />
Un palindrome est un mot ou une phrase qui est orthographié de la même manière à la fois vers l'avant et vers l'arrière, ignorant la ponctuation, la casse et l'espacement.<br />
**Remarque** : Vous devrez supprimer **tous les caractères non alphanumériques** (ponctuation, espaces et symboles) et transformer tout dans la même casse (minuscules ou majuscules) afin de vérifier les palindromes.<br />
Nous passerons des chaînes avec différents formats, tels que `"racecar"`, `"RaceCar"`, et `"race CAR"`.<br />
Nous passerons également des chaînes avec des symboles spéciaux, tels que `"2A3*3a2"`, `"2A3 3a2"`, and `"2_A3*3#A2"`.
:::

:::tip missions
- `palindrome("eye")` devrait renvoyer a boolean.
- `palindrome("eye")` devrait renvoyer `true`.
- `palindrome("_eye")` devrait renvoyer `true`.
- `palindrome("race car")` devrait renvoyer `true`.
- `palindrome("not a palindrome")` devrait renvoyer `false`.
- `palindrome("A man, a plan, a canal. Panama")` devrait renvoyer `true`.
- `palindrome("never odd or even")` devrait renvoyer `true`.
- `palindrome("nope")` devrait renvoyer `false`.
- `palindrome("almostomla")` devrait renvoyer `false`.
- `palindrome("My age is 0, 0 si ega ym.")` devrait renvoyer `true`.
- `palindrome("1 eye for of 1 eye.")` devrait renvoyer `false`.
- `palindrome("0_0 (: /-\ :) 0-0")` devrait renvoyer `true`.
- `palindrome("five|_/|four")` devrait renvoyer `false`.
:::

<nav class="code-col">
<div class="code-col__item">

```js title="javascript"
function palindrome(str) {
    return (
        str.replace(/[\W_]/g, "").toLowerCase() ===
        str
        .replace(/[\W_]/g, "")
        .toLowerCase()
        .split("")
        .reverse()
        .join("")
    );
}

console.log(palindrome("eye"));
console.log(palindrome("_eye"));
console.log(palindrome("race car"));
console.log(palindrome("not a palindrome"));
console.log(palindrome("A man, a plan, a canal. Panama"));
console.log(palindrome("never odd or even"));
console.log(palindrome("nope"));
console.log(palindrome("almostomla"));
console.log(palindrome("My age is 0, 0 si ega ym."));
console.log(palindrome("1 eye for of 1 eye."));
console.log(palindrome("0_0 (: /-\ :) 0-0"));
console.log(palindrome("five|_/|four"));
```

</div>
<div class="code-col__item">

```sh title="console"












true
true
true
false
true
true
false
false
true
false
true
false
```

</div></nav>

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-palindrome-checker/16004)

:::note guide : Vérificateur de Palindrome

### Explication du problème

Notre objectif pour résoudre ce problème est de ranger la chaîne passée et de vérifier s'il s'agit bien d'un palindrome.
- Si vous n'êtes pas sûr de ce qu'est un palindrome, c'est un mot ou une phrase qui, lorsqu'il est inversé, renvoie la même chose vers l'avant ou vers l'arrière. Un exemple simple est `mom`, lorsque vous inversez les lettres, cela signifie la même chose ! Un autre exemple de palindrome est `race car`. Lorsque nous retirons tout ce qui n'est pas un caractère, cela devient `racecar` qui est le même orthographié en avant ou en arrière !
Une fois que nous avons déterminé s'il s'agit d'un palindrome ou non, nous voulons retourner `true` ou `false` en fonction de nos résultats.

#### Liens pertinents

- [String.prototype.replace](http://forum.freecodecamp.com/t/javascript-string-prototype-replace/15942)
- [String.prototype.toLowerCase](http://forum.freecodecamp.com/t/javascript-string-prototype-tolowercase/15948)

### Astuces

<Tabs
    className="codeTabs"
    defaultValue="indice1"
    values={[
        {label: 'Indice 1', value: 'indice1'},
        {label: 'Indice 2', value: 'indice2'},
        {label: 'Indice 3', value: 'indice3'},
    ]}
>
<TabItem value="indice1">

Les expressions régulières, `RegEx`, peuvent être utilisées pour supprimer les caractères indésirables de la chaîne.

</TabItem>

<TabItem value="indice2">

Les méthodes `Array.prototype.split` et `Array.prototype.join` peuvent être utiles ici. Les boucles `for` et `while` sont une autre alternative, ou pourquoi pas même `map` !

</TabItem>

<TabItem value="indice3">

`String.prototype.toLowerCase` peut être utilisé pour mettre une chaîne en minuscules.

</TabItem>

</Tabs>

----

### Solutions

<Tabs
    className="codeTabs"
    defaultValue="solution1"
    values={[
        {label: 'Solution 1', value: 'solution1'},
        {label: 'Solution 2', value: 'solution2'},
        {label: 'Solution 3', value: 'solution3'},
    ]}
>

<TabItem value="solution1">

```js
function palindrome(str) {
    return (
        str.replace(/[\W_]/g, "").toLowerCase() ===
        str
        .replace(/[\W_]/g, "")
        .toLowerCase()
        .split("")
        .reverse()
        .join("")
    );
}
```

#### Explication du code

- Nous commençons par utiliser des expressions régulières pour remplacer les espaces blancs ou les caractères non alphanumériques par rien (ou `null`), ce qui les supprime essentiellement de la chaîne.
- Ensuite, nous enchaînons `.toLowerCase()` pour supprimer les majuscules car `A` est un caractère différent de `a`. Le problème ne nous a pas demandé de nous soucier de nous assurer que la casse des caractères était identique, juste l'orthographe.
- Notre prochaine étape consiste à reprendre notre chaîne et `.split()`, `.reverse()`, et enfin `.join()` à nouveau ensemble.
- La dernière étape est de vérifier que la chaîne est la même en avant et en arrière et de renvoyer notre résultat !

#### Liens pertinents

- [String.prototype.split](http://forum.freecodecamp.com/t/javascript-string-prototype-split/15944)
- [Array.prototype.reverse](http://forum.freecodecamp.com/t/javascript-array-prototype-reverse/14300)
- [Array.prototype.join](http://forum.freecodecamp.com/t/javascript-array-prototype-join/14292)


</TabItem>

<TabItem value="solution2">

```js
function palindrome(str) {
  str = str.toLowerCase().replace(/[\W_]/g, "");
  for (var i = 0, len = str.length - 1; i < len / 2; i++) {
    if (str[i] !== str[len - i]) {
      return false;
    }
  }
  return true;
}
```

#### Explication du code

- Nous commençons par utiliser les mêmes méthodes pour remplacer les caractères que nous ne voulons pas dans la chaîne en utilisant `RegEx`, des expressions régulières, puis nous mettons notre chaîne en minuscules.
- Ensuite, nous configurons notre boucle `for` et déclarons un index `i` pour garder une trace de la boucle. Nous définissons notre séquence d'échappement sur lorsque `i` est supérieur à la longueur de la chaîne divisée par deux, ce qui indique à la boucle de s'arrêter après le point à mi-chemin de la chaîne. Et finalement nous avons mis `i` pour incrémenter après chaque boucle.
- À l'intérieur de chaque boucle, nous voulons vérifier que la lettre de l'élément `[i]` est égale à la lettre de la longueur de la chaîne moins `i`, `[str.length - i]`. À chaque boucle, l'élément qui est vérifié des deux côtés de la chaîne se rapproche du centre jusqu'à ce que nous ayons vérifié toutes les lettres. Si à un moment donné les lettres ne correspondent pas, nous retournons `false`. Si la boucle se termine avec succès, cela signifie que nous avons un palindrome et donc nous retournons `true` !

#### Liens pertinents

- [Regex](https://forum.freecodecamp.com/t/regular-expressions-resources/15931)

</TabItem>

<TabItem value="solution3">

```js
// cette solution fonctionne au minimum 7 fois mieux, au maximum infiniment mieux.
// lire l'explication de la raison.
function palindrome(str) {
    // attribuer un pointeur avant et arrière
    let front = 0;
    let back = str.length - 1;

    // les pointeurs avant et arrière ne se rencontrent pas toujours au milieu, alors utilisez (arrière avant)
    while (back > front) {
        // incrémente le pointeur avant si le caractère actuel ne répond pas aux critères
        if (str[front].match(/[\W_]/)) {
        front++;
        continue;
        }
        // décrémente le pointeur arrière si le caractère actuel ne répond pas aux critères
        if (str[back].match(/[\W_]/)) {
        back--;
        continue;
        }
        // fait enfin la comparaison sur le caractère courant
        if (str[front].toLowerCase() !== str[back].toLowerCase()) return false;
        front++;
        back--;
    }

    // si la chaîne entière a été comparée sans retourner false, c'est un palindrome!
    return true;
}
```

#### Explication du code

- J'ai eu ce problème lors d'une interview. Je suis rapidement arrivé à la solution de base et l'intervieweur m'a demandé de l'améliorer. L'algorithme prendrait beaucoup trop de temps s'il passait la Bible comme chaîne. Il voulait que ce soit instantané.
- Les solutions les plus simples fonctionnent très mal sur les longues chaînes car elles opèrent plusieurs fois sur la chaîne entière (`toLowerCase()`, `replace()`, `split()`, `reverse()`, `join()`) avant de comparer la chaîne entière deux fois.
- La beauté de cette solution est qu’elle n’a jamais besoin de lire toute la chaîne, même une seule fois, pour savoir que ce n’est pas un palindrome. Pourquoi lire toute la chaîne si vous pouvez dire que ce n’est pas un palindrome simplement en regardant deux lettres ?
- Utilise une boucle `while` au lieu d'une boucle `for` comme meilleure pratique - parce que nous utilisons deux variables, l'une est l'index commençant au début de la chaîne et l'autre commence à la fin de la chaîne.

#### Liens pertinents

- [Cyclomatic Complexity](https://fr.wikipedia.org/wiki/Nombre_cyclomatique)

</TabItem>

</Tabs>

:::

-----



## 2. Convertisseur de chiffres romains

[Learn JavaScript Algorithms and Data Structures Projects: Roman Numeral Converter | freeCodeCamp.org](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/javascript-algorithms-and-data-structures-projects/roman-numeral-converter)

:::info instructions
Convertissez le nombre donné en un chiffre romain.<br />
Toutes les réponses en [chiffres romains](https://www.mathsisfun.com/roman-numerals.html) doivent être fournies en majuscules.
:::

:::tip missions
- `convertToRoman(2)` devrait renvoyer "II".
- `convertToRoman(3)` devrait renvoyer "III".
- `convertToRoman(4)` devrait renvoyer "IV".
- `convertToRoman(5)` devrait renvoyer "V".
- `convertToRoman(9)` devrait renvoyer "IX".
- `convertToRoman(12)` devrait renvoyer "XII".
- `convertToRoman(16)` devrait renvoyer "XVI".
- `convertToRoman(29)` devrait renvoyer "XXIX".
- `convertToRoman(44)` devrait renvoyer "XLIV".
- `convertToRoman(45)` devrait renvoyer "XLV".
- `convertToRoman(68)` devrait renvoyer "LXVIII".
- `convertToRoman(83)` devrait renvoyer "LXXXIII".
- `convertToRoman(97)` devrait renvoyer "XCVII".
- `convertToRoman(99)` devrait renvoyer "XCIX".
- `convertToRoman(400)` devrait renvoyer "CD".
- `convertToRoman(500)` devrait renvoyer "D".
- `convertToRoman(501)` devrait renvoyer "DI".
- `convertToRoman(649)` devrait renvoyer "DCXLIX".
- `convertToRoman(798)` devrait renvoyer "DCCXCVIII".
- `convertToRoman(891)` devrait renvoyer "DCCCXCI".
- `convertToRoman(1000)` devrait renvoyer "M".
- `convertToRoman(1004)` devrait renvoyer "MIV".
- `convertToRoman(1006)` devrait renvoyer "MVI".
- `convertToRoman(1023)` devrait renvoyer "MXXIII".
- `convertToRoman(2014)` devrait renvoyer "MMXIV".
- `convertToRoman(3999)` devrait renvoyer "MMMCMXCIX".
:::

<nav class="code-col">
<div class="code-col__item">

```js title="javascript"
let convertToRoman = function(num) {
    let decimalValue = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    let romanNumeral = [
        "M",
        "CM",
        "D",
        "CD",
        "C",
        "XC",
        "L",
        "XL",
        "X",
        "IX",
        "V",
        "IV",
        "I"
    ];
    let romanized = "";
    for (let index = 0; index < decimalValue.length; index++) {
        while (decimalValue[index] <= num) {
        romanized += romanNumeral[index];
        num -= decimalValue[index];
        }
    }
    return romanized;
};

console.log(convertToRoman(36));
console.log(convertToRoman(2));
console.log(convertToRoman(3));
console.log(convertToRoman(4));
console.log(convertToRoman(5));
console.log(convertToRoman(9));
console.log(convertToRoman(12));
console.log(convertToRoman(16));
console.log(convertToRoman(29));
console.log(convertToRoman(44));
console.log(convertToRoman(45));
console.log(convertToRoman(68));
console.log(convertToRoman(83));
console.log(convertToRoman(97));
console.log(convertToRoman(99));
console.log(convertToRoman(400));
console.log(convertToRoman(500));
console.log(convertToRoman(501));
console.log(convertToRoman(649));
console.log(convertToRoman(798));
console.log(convertToRoman(891));
console.log(convertToRoman(1000));
console.log(convertToRoman(1004));
console.log(convertToRoman(1006));
console.log(convertToRoman(1023));
console.log(convertToRoman(2014));
console.log(convertToRoman(3999));
```


</div>
<div class="code-col__item">

```sh title="console"



























XXXVI
II
III
IV
V
IX
XII
XVI
XXIX
XLIV
XLV
LXVIII
LXXXIII
XCVII
XCIX
CD
D
DI
DCXLIX
DCCXCVIII
DCCCXCI
M
MIV
MVI
MXXIII
MMXIV
MMMCMXCIX
```

</div></nav>

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-roman-numeral-converter/16044)

:::note guide :Convertisseur de chiffres romains

### Explication du problème

Vous allez créer un programme qui convertit un entier en chiffre romain.

#### Liens pertinents
 
- [Roman Numerals](https://www.mathsisfun.com/roman-numerals.html)
- [Array.splice()](http://forum.freecodecamp.com/t/javascript-array-prototype-splice/14307)
- [Array.indexOf()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/indexOf)
- [Array.join()](http://forum.freecodecamp.com/t/javascript-array-prototype-join/14292)

### Astuces

<Tabs
    className="codeTabs"
    defaultValue="indice1"
    values={[
        {label: 'Indice 1', value: 'indice1'},
        {label: 'Indice 2', value: 'indice2'},
        {label: 'Indice 3', value: 'indice3'},
    ]}
>
<TabItem value="indice1">

La création de deux tableaux, un avec les chiffres romains et un avec l'équivalent décimal pour les nouveaux formulaires sera très utile.

</TabItem>

<TabItem value="indice2">

Si vous ajoutez les nombres aux tableaux qui précèdent l'introduction de la nouvelle lettre, comme les valeurs pour 4, 9 et 40, cela vous fera économiser beaucoup de code.

</TabItem>

<TabItem value="indice3">

Vous ne pouvez pas avoir plus de trois chiffres romains consécutifs ensemble.

</TabItem>

</Tabs>

----

### Solutions

<Tabs
    className="codeTabs"
    defaultValue="solution1"
    values={[
        {label: 'Solution 1', value: 'solution1'},
        {label: 'Solution 2', value: 'solution2'},
        {label: 'Solution 3', value: 'solution3'},
        {label: 'Solution 4', value: 'solution4'},
    ]}
>
<TabItem value="solution1">

```js
var convertToRoman = function(num) {
    var decimalValue = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    var romanNumeral = [
        "M",
        "CM",
        "D",
        "CD",
        "C",
        "XC",
        "L",
        "XL",
        "X",
        "IX",
        "V",
        "IV",
        "I"
    ];

    var romanized = "";

    for (var index = 0; index < decimalValue.length; index++) {
        while (decimalValue[index] <= num) {
        romanized += romanNumeral[index];
        num -= decimalValue[index];
        }
    }

    return romanized;
};

// tester ici
convertToRoman(36);
```

#### Explication du code

- Nous commençons par créer deux tableaux avec une conversion par défaut avec des indices correspondants. Ceux-ci sont appelés `decimalValue` et `romanNumeral`. Nous créons également une variable de chaîne vide, `romanized`, qui hébergera le nombre romain final.
- En utilisant une boucle `for`, nous parcourons les indices du tableau `decimalValue`. Nous continuons à boucler jusqu'à ce que la valeur `index` actuel tienne dans `num`.
- Ensuite, nous ajoutons le chiffre romain et r'éduisons `num` par l'équivalent décimal.
- Enfin, nous retournons la valeur de `romanized`.

#### Liens pertinents

- [For Loops](http://forum.freecodecamp.com/t/javascript-for-loop/14666)
- [While Loops]

</TabItem>

<TabItem value="solution2">

```js
function convertToRoman(num) {
  var romans = ["I", "V", "X", "L", "C", "D", "M"],
    ints = [],
    romanNumber = [],
    numeral = "",
    i;
  while (num) {
    ints.push(num % 10);
    num = Math.floor(num / 10);
  }
  for (i = 0; i < ints.length; i++) {
    units(ints[i]);
  }
  function units() {
    numeral = romans[i * 2];
    switch (ints[i]) {
      case 1:
        romanNumber.push(numeral);
        break;
      case 2:
        romanNumber.push(numeral.concat(numeral));
        break;
      case 3:
        romanNumber.push(numeral.concat(numeral).concat(numeral));
        break;
      case 4:
        romanNumber.push(numeral.concat(romans[i * 2 + 1]));
        break;
      case 5:
        romanNumber.push(romans[i * 2 + 1]);
        break;
      case 6:
        romanNumber.push(romans[i * 2 + 1].concat(numeral));
        break;
      case 7:
        romanNumber.push(romans[i * 2 + 1].concat(numeral).concat(numeral));
        break;
      case 8:
        romanNumber.push(
          romans[i * 2 + 1]
            .concat(numeral)
            .concat(numeral)
            .concat(numeral)
        );
        break;
      case 9:
        romanNumber.push(romans[i * 2].concat(romans[i * 2 + 2]));
    }
  }
  return romanNumber
    .reverse()
    .join("")
    .toString();
}

// tester ici
convertToRoman(97);
```

#### Explication du code

- Créez un tableau de chiffres romains (`romans`).
- Utilisez une boucle `for` pour créer un tableau des chiffres (`ints`) du nombre.
- Parcourez le tableau de chiffres (base 10) et comme vous le faites, incrémentez l'index en chiffres romains (base 5) de 2 (`numeral = romans [i*2]`).
- Dans la boucle, utilisez `Switch Case` pour pousser les chiffres romains appropriés (vers l'arrière) sur ce tableau.
- Inversez le tableau des chiffres romains et transformez-le en chaîne.

#### Liens pertinents

- [For Loops](http://forum.freecodecamp.com/t/javascript-for-loop/14666)
- [While Loops]
- [Math](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Math)

</TabItem>

<TabItem value="solution3">

```js
function convertToRoman(num) {
  var romans = [
      // 10^i 10^i*5
      ["I", "V"], // 10^0
      ["X", "L"], // 10^1
      ["C", "D"], // 10^2
      ["M"] // 10^3
    ],
    digits = num
      .toString()
      .split("")
      .reverse()
      .map(function(item, index) {
        return parseInt(item);
      }),
    numeral = "";

  // Boucle sur chaque chiffre, en commençant par les uns
  for (var i = 0; i < digits.length; i++) {
    // Crée un chiffre romain qui ignore les 5 multiples et les règles de raccourcissement
    numeral = romans[i][0].repeat(digits[i]) + numeral;
    // Recherche une version à 5 chiffres romains
    if (romans[i][1]) {
      numeral = numeral
        // Remplace les occurrences de 5 * 10^i par le chiffre romain à 5 multiples correspondant
        .replace(romans[i][0].repeat(5), romans[i][1])
        // Raccourcir les occurrences de 9 * 10^i
        .replace(
          romans[i][1] + romans[i][0].repeat(4),
          romans[i][0] + romans[i + 1][0]
        )
        // Raccourcir les occurrences de 4 * 10^i
        .replace(romans[i][0].repeat(4), romans[i][0] + romans[i][1]);
    }
  }

  return numeral;
}

// tester ici
convertToRoman(36);
```

#### Explication du code

- Utilisez un tableau (`romans`) pour créer une matrice contenant le chiffre romain pour une puissance donnée de 10 et, si disponible, le chiffre romain pour cette puissance de 10 fois 5.
- Convertissez le nombre d'entrée (`num`) en un tableau inversé de chiffres (`digits`) afin que nous puissions parcourir ces chiffres en commençant par la position des unités et en montant.
- Parcourez chaque chiffre, en commençant par les uns, et créez une chaîne de chiffres romains en ajoutant chaque chiffre romain de puissance supérieure au début de la chaîne `numeral` un nombre de fois égal à `digit`. Cette chaîne initiale ignore les chiffres romains qui sont une puissance de 10 fois 5 et ignore également les règles de raccourcissement.
- Si la puissance pertinente de 10 a un chiffre romain multiple de 5, dans `numeral`, remplacez les occurrences 5 consécutives par le chiffre romain multiple 5 pertinent (c'est-à-dire, V, L ou D) et raccourcissez les occurrences de 9 * 10^i (par exemple, VIIII à VIX) et 4 * 10^i (par exemple, XXXX à XL). L'ordre est important ici !
- Enfin, retournez `numeral`.

#### Liens pertinents


- [For Loops](http://forum.freecodecamp.com/t/javascript-for-loop/14666)
- [.split()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/split)
- [.reverse()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/reverse)
- [.map()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/map)
- [.toString()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/toString)
- [parseInt()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/parseInt)
- [.replace()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/replace)
- [.repeat()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/repeat)

</TabItem>

<TabItem value="solution4">

```js
function convertToRoman(num) {
  function getNumeral(digit, lowStr, midStr, nextStr) {
    switch (true) {
      case digit <= 3:
        return lowStr.repeat(digit);
      case digit === 4:
        return lowStr + midStr;
      case digit <= 8: // digits 5-8
        return midStr + lowStr.repeat(digit - 5);
      default: // digit 9
        return lowStr + nextStr
    }
  }

  let str = ""

  // Thousands
  str += "M".repeat(Math.floor(num/1000));
  num %= 1000;

  // Hundreds
  str += getNumeral(Math.floor(num/100), 'C', 'D', 'M')
  num %= 100;

  // Tens
  str += getNumeral(Math.floor(num/10), 'X', 'L', 'C')
  num %= 10;

  // Ones
  str += getNumeral(num, 'I', 'V', 'X')

  return str;
}

convertToRoman(36);
```

#### Explication du code

Les chiffres romains jusqu'à 999 suivent un modèle pour chaque chiffre. Pour les nombres à un chiffre, vous avez les chaînes `I`, `V` et `X`. Pour les multiples de dix, vous avez `X`, `L` et `C`. Pour les multiples de 100, vous avez `C`, `D` et `M`. Donc, pour obtenir le chiffre romain final, il suffit de trouvez la chaîne individuelle basée sur ces 3 combinaisons, puis concaténez-les ensemble.
- Définissez une fonction qui prendra les trois chaînes et un seul chiffre et affichera son chiffre romain en fonction du modèle.
- Pour les nombres supérieurs à 1000, répétez simplement `M` pour chaque millier.
- Utilisez la fonction pour obtenir le chiffre romain pour 100, 10 et 1.

</TabItem>

</Tabs>

:::

-----



## 3. Chiffre de Césars

[Learn JavaScript Algorithms and Data Structures Projects: Caesars Cipher | freeCodeCamp.org](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/javascript-algorithms-and-data-structures-projects/caesars-cipher)

:::info instructions
L'un des *chiffrements* les plus simples et les plus connus est un *chiffrement César*, également connu sous le nom de *chiffrement par décalage*. Dans un chiffrement par décalage, les significations des lettres sont décalées d'une certaine quantité définie.<br />
Une utilisation moderne courante est le chiffrement [ROT13](https://fr.wikipedia.org/wiki/ROT13), où les valeurs des lettres sont décalées de 13 places. Ainsi 'A' ↔ 'N', 'B' ↔ 'O' et ainsi de suite.<br />
Écrivez une fonction qui prend une chaîne codée ROT13 en entrée et renvoie une chaîne décodée.<br />
Toutes les lettres seront en majuscules. Ne transformez aucun caractère non alphabétique (c'est-à-dire espaces, ponctuation), mais transmettez-les.
:::

:::tip missions
- `rot13("SERR PBQR PNZC")` devrait décoder en `FREE CODE CAMP`.
- `rot13("SERR CVMMN!")` devrait décoder en `FREE PIZZA!`
- `rot13("SERR YBIR?")` devrait décoder en `FREE LOVE?`
- `rot13("GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT.")` devrait décoder en `THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.`
:::

<nav class="code-col">
<div class="code-col__item">

```js title="javascript"
function rot13(str) {
    return (
        str
        .split("")
        .map.call(str, function(char) {
            let x = char.charCodeAt(0);
            if (x < 65 || x > 90) {
                return String.fromCharCode(x);
            }
            else if (x < 78) {
                return String.fromCharCode(x + 13);
            }
            return String.fromCharCode(x - 13);
        })
        .join("")
    );
}

console.log(rot13("SERR PBQR PNZC"));
console.log(rot13("SERR CVMMN!"));
console.log(rot13("SERR YBIR?"));
console.log(rot13("GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT."));
```

</div>
<div class="code-col__item">

```sh title="console"


















FREE CODE CAMP
FREE PIZZA!
FREE LOVE?
THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.
```

</div></nav>

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-caesars-cipher/16003)

:::note guide : Chiffre de Césars

### Astuces

<Tabs
    className="codeTabs"
    defaultValue="indice1"
    values={[
        {label: 'Indice 1', value: 'indice1'},
        {label: 'Indice 2', value: 'indice2'},
        {label: 'Indice 3', value: 'indice3'},
    ]}
>
<TabItem value="indice1">

Utilisez `String.charCodeAt()` pour convertir le caractère anglais en ASCII.

</TabItem>

<TabItem value="indice2">

Utilisez `String.fromCharCode()` pour convertir ASCII en caractère anglais.

</TabItem>

<TabItem value="indice3">

Laissez tout ce qui n’intervient pas entre A-Z tel quel.

</TabItem>

</Tabs>


### Solutions

<Tabs
    className="codeTabs"
    defaultValue="solution1"
    values={[
        {label: 'Solution 1', value: 'solution1'},
        {label: 'Solution 2', value: 'solution2'},
        {label: 'Solution 3', value: 'solution3'},
        {label: 'Solution 4', value: 'solution4'},
        {label: 'Solution 5', value: 'solution5'},
    ]}
>
<TabItem value="solution1">

```js
function rot13(str) {
    // Divise str en un tableau de caractères
    return (
        str
        .split("")
        // Itère sur chaque caractère du tableau
        .map.call(str, function(char) {
            // Convertit un caractère en code de caractère
            var x = char.charCodeAt(0);
            // Vérifie si le caractère se situe entre A-Z
            if (x < 65 || x > 90) {
                return String.fromCharCode(x); // Renvoie le caractère non converti
            }
            // N = ASCII 78, si le code de caractère est inférieur à 78, avance de 13 places
            else if (x < 78) {
                return String.fromCharCode(x + 13);
            }
            // Sinon décale le caractère de 13 places vers l'arrière
            return String.fromCharCode(x - 13);
        })
        .join("")
    ); // Rejoint le tableau dans une chaîne
}
```

#### Explication du code

- Une variable de chaîne `nstr` est déclarée et initialisée pour stocker la chaîne décodée.
- La boucle `for` est utilisée pour parcourir chaque caractère de la chaîne d'entrée.
- Si le caractère n'est pas des alphabets anglais majuscules (c'est-à-dire que son ascii ne se situe pas entre 65 et 91), nous le laisserons tel quel et [continue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/continue) avec l'itération suivante.
- S'il s'agit de l'alphabet anglais majuscule, nous soustrayons 13 de son code ascii.
- Si le code ascii est inférieur à 78, il sera hors de portée lorsqu'il sera soustrait de 13, nous y ajouterons donc 26 (nombre de lettres dans l'alphabet anglais) afin qu'après A, il revienne à Z. par exemple M(77) <==> 77-13 = 64 (pas un alphabet anglais) +26 = 90 <==> Z(90).

#### Liens pertinents

- [Array.prototype.map](https://forum.freecodecamp.com/t/javascript-array-prototype-map/14294)
- [String.prototype.split](https://forum.freecodecamp.com/t/javascript-string-prototype-split/15944)
- [Array.prototype.join](https://forum.freecodecamp.com/t/javascript-array-prototype-join/14292)

</TabItem>

<TabItem value="solution2">

```js
// Solution avec expression régulière et tableau de codes de caractères ASCII
function rot13(str) {
    var rotCharArray = [];
    var regEx = /[A-Z]/;
    str = str.split("");
    for (var x in str) {
        if (regEx.test(str[x])) {
            // Une approche plus générale
            // possible grâce à l'arithmétique modulaire
            // et nature cyclique de la transformée rot13
            rotCharArray.push(((str[x].charCodeAt() - 65 + 13) % 26) + 65);
        } else {
            rotCharArray.push(str[x].charCodeAt());
        }
    }
    str = String.fromCharCode.apply(String, rotCharArray);
    return str;
}

// Changez les entrées ci-dessous pour tester
rot13("LBH QVQ VG!");
```

#### Explication du code

- Un tableau vide est créé dans une variable appelée `rotCharArray` pour stocker les codes de caractères.
- La variable `regEx` stocke une expression régulière pour toutes les lettres majuscules de A à Z.
- Nous divisons `str` en un tableau de caractères, puis utilisons une boucle `for` pour parcourir chaque caractère du tableau.
- En utilisant une instruction `if`, nous testons pour voir si la chaîne ne contient que des lettres majuscules de A à Z.
- S'il renvoie `true`, nous utilisons la fonction `charCodeAt()` et la transformation `rot13` pour renvoyer la valeur correcte, sinon nous renvoyons la valeur initiale.
- Nous retournons ensuite la chaîne avec les codes de caractères de la variable `rotCharArray`.

#### Explication de l'algorithme

```js
    ALPHA	KEY	BASE 	 	 	 ROTATED	ROT13
    -------------------------------------------------------------
    [A]     65  <=>   0 + 13  =>  13 % 26  <=>  13 + 65 = 78 [N]
    [B]     66  <=>   1 + 13  =>  14 % 26  <=>  14 + 65 = 79 [O]
    [C]     67  <=>   2 + 13  =>  15 % 26  <=>  15 + 65 = 80 [P]
    [D]     68  <=>   3 + 13  =>  16 % 26  <=>  16 + 65 = 81 [Q]
    [E]     69  <=>   4 + 13  =>  17 % 26  <=>  17 + 65 = 82 [R]
    [F]     70  <=>   5 + 13  =>  18 % 26  <=>  18 + 65 = 83 [S]
    [G]     71  <=>   6 + 13  =>  19 % 26  <=>  19 + 65 = 84 [T]
    [H]     72  <=>   7 + 13  =>  20 % 26  <=>  20 + 65 = 85 [U]
    [I]     73  <=>   8 + 13  =>  21 % 26  <=>  21 + 65 = 86 [V]
    [J]     74  <=>   9 + 13  =>  22 % 26  <=>  22 + 65 = 87 [W]
    [K]     75  <=>  10 + 13  =>  23 % 26  <=>  23 + 65 = 88 [X]
    [L]     76  <=>  11 + 13  =>  24 % 26  <=>  24 + 65 = 89 [Y]
    [M]     77  <=>  12 + 13  =>  25 % 26  <=>  25 + 65 = 90 [Z]
    [N]     78  <=>  13 + 13  =>  26 % 26  <=>   0 + 65 = 65 [A]
    [O]     79  <=>  14 + 13  =>  27 % 26  <=>   1 + 65 = 66 [B]
    [P]     80  <=>  15 + 13  =>  28 % 26  <=>   2 + 65 = 67 [C]
    [Q]     81  <=>  16 + 13  =>  29 % 26  <=>   3 + 65 = 68 [D]
    [R]     82  <=>  17 + 13  =>  30 % 26  <=>   4 + 65 = 69 [E]
    [S]     83  <=>  18 + 13  =>  31 % 26  <=>   5 + 65 = 70 [F]
    [T]     84  <=>  19 + 13  =>  32 % 26  <=>   6 + 65 = 71 [G]
    [U]     85  <=>  20 + 13  =>  33 % 26  <=>   7 + 65 = 72 [H]
    [V]     86  <=>  21 + 13  =>  34 % 26  <=>   8 + 65 = 73 [I]
    [W]     87  <=>  22 + 13  =>  35 % 26  <=>   9 + 65 = 74 [J]
    [X]     88  <=>  23 + 13  =>  36 % 26  <=>  10 + 65 = 75 [K]
    [Y]     89  <=>  24 + 13  =>  37 % 26  <=>  11 + 65 = 76 [L]
    [Z]     90  <=>  25 + 13  =>  38 % 26  <=>  12 + 65 = 77 [M]
```

#### Liens pertinents

- [Function.apply](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Function/apply)
- [Regex](https://forum.freecodecamp.com/t/regular-expressions-resources/15931)
- [Regex.test](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp/test)

</TabItem>

<TabItem value="solution3">

```js
function rot13(str) {
  // LBH QVQ VG!
  return str.replace(/[A-Z]/g, L =>
    String.fromCharCode((L.charCodeAt(0) % 26) + 65)
  );
}
```

#### Explication du code

Comprendre l'opérateur modulo (*parfois appelé opérateur modulus*) représenté symboliquement par `%` en JavaScript est essentiel pour comprendre l'algorithme.<br />
C'est un opérateur intéressant qui apparaît dans divers endroits de l'ingénierie, par exemple en cryptographie.<br />
En gros, opéré sur un nombre, il divise le nombre par le diviseur donné et donne le reste de la division.<br />
Par exemple :

- `0 % 5 = 0` car `0 / 5 = 0` et le reste est `0`.
- `2 % 5 = 2` car `2 / 5 = 0` et le reste est `2`.
- `4 % 5 = 4` car `4 / 5 = 0` et le reste est `4`.
- `5 % 5 = 0` car `5 / 5 = 1` et le reste est `0`.
- `7 % 5 = 2` car `7 / 5 = 1` et le reste est `2`.
- `9 % 5 = 4` car `9 / 5 = 1` et le reste est `4`.
- `10 % 5 = 0` car `10 / 5 = 2` et le reste est `0`.

Mais vous devez avoir remarqué un modèle ici.<br />
Comme vous l'avez peut-être remarqué, l'étonnant opérateur modulo englobe la valeur LHS lorsqu'il atteint juste des multiples de la valeur RHS.<br />
Par exemple. dans notre cas, lorsque `LHS = 5`, il est retourné à `0`<br />
OU<br />
lorsque `LHS = 10`, il revient à `0`.<br />
Par conséquent, nous voyons le modèle suivant émerger :

```js
     0 ⇔ 0
     1 ⇔ 1
     2 ⇔ 2
     3 ⇔ 3
     4 ⇔ 4
     5 ⇔ 0
     6 ⇔ 1
     7 ⇔ 2
     8 ⇔ 3
     9 ⇔ 4
    10 ⇔ 0
```

Par conséquent, nous concluons qu'en utilisant l'opérateur modulo, on peut mapper une plage de valeurs à une plage comprise entre [`0` et `DIVISOR - 1`]. Dans notre cas, nous avons mappé `[5 - 9]` entre `[0 - 4]` ou mappé `[6 - 10]` entre `[0 - 4]`.<br />
Avez-vous compris jusque là ?<br />
Considérons maintenant le mappage d'une plage de `26` nombres, c'est-à-dire entre `[65 - 90]` qui représente les majuscules [alphabets anglais] dans le [jeu de caractères Unicode](https://unicode-table.com/en/alphabets/) à une plage de nombres entre `[0 - 25]`.

```js
    [A]  65 % 26 ⇔ 13
    [B]  66 % 26 ⇔ 14
    [C]  67 % 26 ⇔ 15
    [D]  68 % 26 ⇔ 16
    [E]  69 % 26 ⇔ 17
    [F]  70 % 26 ⇔ 18
    [G]  71 % 26 ⇔ 19
    [H]  72 % 26 ⇔ 20
    [I]  73 % 26 ⇔ 21
    [J]  74 % 26 ⇔ 22
    [K]  75 % 26 ⇔ 23
    [L]  76 % 26 ⇔ 24
    [M]  77 % 26 ⇔ 25
    [N]  78 % 26 ⇔  0
    [O]  79 % 26 ⇔  1
    [P]  80 % 26 ⇔  2
    [Q]  81 % 26 ⇔  3
    [R]  82 % 26 ⇔  4
    [S]  83 % 26 ⇔  5
    [T]  84 % 26 ⇔  6
    [U]  85 % 26 ⇔  7
    [V]  86 % 26 ⇔  8
    [W]  87 % 26 ⇔  9
    [X]  88 % 26 ⇔ 10
    [Y]  89 % 26 ⇔ 11
    [Z]  90 % 26 ⇔ 12
```

Comme vous pouvez le constater, chaque nombre dans la plage de `[65 - 90]` correspond à un numéro unique compris entre `[0 - 25]`.<br />
Vous avez peut-être également remarqué que chaque nombre donné (par exemple `65`) correspond à un autre nombre (par exemple `13`) qui peut être utilisé comme valeur de décalage (c'est-à-dire `65 + OFFSET`) pour obtenir le ROT13 du nombre donné.<br />
Par exemple, `65` map à `13` qui peuvent être prises comme valeur de décalage et ajoutées à `65` pour donner `78`.

```js
    [A]  65 % 26 ⇔ 13 + 65 =  78 [N]
    [B]  66 % 26 ⇔ 14 + 65 =  79 [O]
    [C]  67 % 26 ⇔ 15 + 65 =  80 [P]
    [D]  68 % 26 ⇔ 16 + 65 =  81 [Q]
    [E]  69 % 26 ⇔ 17 + 65 =  82 [R]
    [F]  70 % 26 ⇔ 18 + 65 =  83 [S]
    [G]  71 % 26 ⇔ 19 + 65 =  84 [T]
    [H]  72 % 26 ⇔ 20 + 65 =  85 [U]
    [I]  73 % 26 ⇔ 21 + 65 =  86 [V]
    [J]  74 % 26 ⇔ 22 + 65 =  87 [W]
    [K]  75 % 26 ⇔ 23 + 65 =  88 [X]
    [L]  76 % 26 ⇔ 24 + 65 =  89 [Y]
    [M]  77 % 26 ⇔ 25 + 65 =  90 [Z]
    [N]  78 % 26 ⇔  0 + 65 =  65 [A]
    [O]  79 % 26 ⇔  1 + 65 =  66 [B]
    [P]  80 % 26 ⇔  2 + 65 =  67 [C]
    [Q]  81 % 26 ⇔  3 + 65 =  68 [D]
    [R]  82 % 26 ⇔  4 + 65 =  69 [E]
    [S]  83 % 26 ⇔  5 + 65 =  70 [F]
    [T]  84 % 26 ⇔  6 + 65 =  71 [G]
    [U]  85 % 26 ⇔  7 + 65 =  72 [H]
    [V]  86 % 26 ⇔  8 + 65 =  73 [I]
    [W]  87 % 26 ⇔  9 + 65 =  74 [J]
    [X]  88 % 26 ⇔ 10 + 65 =  75 [K]
    [Y]  89 % 26 ⇔ 11 + 65 =  76 [L]
    [Z]  90 % 26 ⇔ 12 + 65 =  77 [M]
```

#### Explication du code

- La fonction [`String.prototype.replace`](http://forum.freecodecamp.com/t/javascript-string-prototype-replace/15942) vous permet de transformer une `string` en fonction d'une correspondance de modèle (définie par une expression régulière) et de la [fonction de transformation](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/replace#Indiquer_une_fonction_comme_param%C3%A8tre) (qui est appliquée à chacune des correspondances de modèle).
- La syntaxe de la [fonction fléchée](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/Fonctions_fl%C3%A9ch%C3%A9es) est utilisée pour écrire le paramètre de la fonction `replace()`.
- `L` représente une seule unité, de chaque correspondance de motif avec `/[A-Z]/g` - qui est chaque lettre majuscule de l'alphabet, de A à Z, présente dans la chaîne.
- La fonction fléchée applique la transformation `rot13` à chaque lettre majuscule de l'alphabet anglais présente dans la chaîne donnée.

#### Liens pertinents

- [String.prototype.replace()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/replace)

</TabItem>

<TabItem value="solution4">

```js
function rot13(str) {
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    return str
      .split('')
      .map(char => {  
        const pos = alphabet.indexOf(char);      
        return pos >= 0 ? alphabet[(pos + 13) % 26] : char;
      })
      .join('');
}
```

</TabItem>

<TabItem value="solution5">

```js
function rot13(str) {
  str.toUpperCase(); // Convertit la chaîne `str` en lettres majuscules
  var abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M"];
  var nop = ["N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
  var arr = str.split(""); // Divise `str` en un tableau où chaque élément est un caractère individuel (y compris les caractères non alphabétiques)

    for (var i = 0; i < arr.length; i++) { // Itére le nombre d'éléments `arr`
      for (var j = 0; j < abc.length; j++) { // Itérer le nombre d'éléments du tableau `abc` /` nop`
      if (arr[i] === abc[j]) {
        arr[i] = nop[j]; // Échange le caractère `arr` pour le caractère de tableau` nop` correspondant
      } else if (arr[i] === nop[j]) {
        arr[i] = abc[j]; // Échange le caractère `arr` pour le caractère de tableau` abc` correspondant
      }
    }
  }

  return arr.join(""); // Rejoint tous les caractères du tableau `arr` dans une chaîne, retournant le` str` déchiffré avec tous les caractères non alphabétiques préservés
}

rot13("FHCRE FRPERG!!!");
```

#### Explication du code

- La chaîne est divisée en un tableau de caractères
- Chaque caractère alphabétique est remplacé par son équivalent décalé
- Le résultat final est joint dans une chaîne et renvoyé

**Remarque :** cette approche fonctionne pour un décalage de 13 caractères. Une approche différente sera nécessaire pour un quart de travail de taille différente.

</TabItem>

</Tabs>

:::

-----



## 4. Validateur de numéro de téléphone

:::info instructions
Renvoie `true` si la chaîne transmise ressemble à un numéro de téléphone américain valide.<br />
L'utilisateur peut remplir le champ du formulaire comme il le souhaite, à condition qu'il ait le format d'un numéro américain valide. Voici des exemples de formats valides pour les numéros américains (reportez-vous aux tests ci-dessous pour d'autres variantes) :

```sh
555-555-5555
(555)555-5555
(555) 555-5555
555 555 5555
5555555555
1 555 555 5555
```

Pour ce défi, une chaîne telle que `800-692-7753` ou `8oo-six427676;laskdjf` vous sera présentée. Votre travail consiste à valider ou rejeter le numéro de téléphone américain en fonction de toute combinaison des formats fournis ci-dessus. L'indicatif régional est requis. Si le code du pays est fourni, vous devez confirmer que le code du pays est `1`. Renvoyez `true` si la chaîne est un numéro de téléphone américain valide ; sinon, retournez `false`.
:::

:::tip missions
- `telephoneCheck("555-555-5555")` devrait renvoyer un booléen.
- `telephoneCheck("1 555-555-5555")` devrait renvoyer true.
- `telephoneCheck("1 (555) 555-5555")` devrait renvoyer true.
- `telephoneCheck("5555555555")` devrait renvoyer true.
- `telephoneCheck("555-555-5555")` devrait renvoyer true.
- `telephoneCheck("(555)555-5555")` devrait renvoyer true.
- `telephoneCheck("1(555)555-5555")` devrait renvoyer true.
- `telephoneCheck("555-5555")` devrait renvoyer false.
- `telephoneCheck("5555555")` devrait renvoyer false.
- `telephoneCheck("1 555)555-5555")` devrait renvoyer false.
- `telephoneCheck("1 555 555 5555")` devrait renvoyer true.
- `telephoneCheck("1 456 789 4444")` devrait renvoyer true.
- `telephoneCheck("123**&!!asdf#")` devrait renvoyer false.
- `telephoneCheck("55555555")` devrait renvoyer false.
- `telephoneCheck("(6054756961)")` devrait renvoyer false.
- `telephoneCheck("2 (757) 622-7382")` devrait renvoyer false.
- `telephoneCheck("0 (757) 622-7382")` devrait renvoyer false.
- `telephoneCheck("-1 (757) 622-7382")` devrait renvoyer false.
- `telephoneCheck("2 757 622-7382")` devrait renvoyer false.
- `telephoneCheck("10 (757) 622-7382")` devrait renvoyer false.
- `telephoneCheck("27576227382")` devrait renvoyer false.
- `telephoneCheck("(275)76227382")` devrait renvoyer false.
- `telephoneCheck("2(757)6227382")` devrait renvoyer false.
- `telephoneCheck("2(757)622-7382")` devrait renvoyer false.
- `telephoneCheck("555)-555-5555")` devrait renvoyer false.
- `telephoneCheck("(555-555-5555")` devrait renvoyer false.
- `telephoneCheck("(555)5(55?)-5555")` devrait renvoyer false.
:::

<nav class="code-col">
<div class="code-col__item">

```js title="javascript"
function telephoneCheck(str) {
  let regex = /^(1\s?)?(\(\d{3}\)|\d{3})[\s\-]?\d{3}[\s\-]?\d{4}$/;
  return regex.test(str);
}

console.log(telephoneCheck("1 555-555-5555"));
console.log(telephoneCheck("1 (555) 555-5555"));
console.log(telephoneCheck("5555555555"));
console.log(telephoneCheck("555-555-5555"));
console.log(telephoneCheck("(555)555-5555"));
console.log(telephoneCheck("1(555)555-5555"));
console.log(telephoneCheck("555-5555"));
console.log(telephoneCheck("5555555"));
console.log(telephoneCheck("1 555)555-5555"));
console.log(telephoneCheck("1 555 555 5555"));
console.log(telephoneCheck("1 456 789 4444"));
console.log(telephoneCheck("123**&!!asdf#"));
console.log(telephoneCheck("55555555"));
console.log(telephoneCheck("(6054756961)"));
console.log(telephoneCheck("2 (757) 622-7382"));
console.log(telephoneCheck("0 (757) 622-7382"));
console.log(telephoneCheck("-1 (757) 622-7382"));
console.log(telephoneCheck("2 757 622-7382"));
console.log(telephoneCheck("10 (757) 622-7382"));
console.log(telephoneCheck("27576227382"));
console.log(telephoneCheck("(275)76227382"));
console.log(telephoneCheck("2(757)6227382"));
console.log(telephoneCheck("2(757)622-7382"));
console.log(telephoneCheck("555)-555-5555"));
console.log(telephoneCheck("(555-555-5555"));
console.log(telephoneCheck("(555)5(55?)-5555"));
```

</div>
<div class="code-col__item">

```sh title="console"





true
true
true
true
true
true
false
false
false
true
true
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
```

</div></nav>

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-telephone-number-validator/16090)

:::note guide : Validateur de numéro de téléphone

### Explication du problème

La tâche n'est pas si difficile à comprendre, sa mise en œuvre est la partie la plus difficile. Vous avez un pour valider un numéro de téléphone américain. Cela signifie qu'il y a un certain nombre de chiffres requis, même si vous n'avez pas besoin de mettre le code du pays, vous aurez toujours besoin de l'indicatif régional et utilisez l'un des rares formats autorisés.

#### Liens pertinents

- [RegExp](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp)
- [regexpal.com](https://www.regexpal.com/)
- [regex101.com/](https://regex101.com/#javascript)

### Astuces

<Tabs
    className="codeTabs"
    defaultValue="indice1"
    values={[
        {label: 'Indice 1', value: 'indice1'},
        {label: 'Indice 2', value: 'indice2'},
        {label: 'Indice 3', value: 'indice3'},
        {label: 'Indice 4', value: 'indice4'},
    ]}
>
<TabItem value="indice1">

Il n'y a aucun moyen de contourner cela, vous devrez rafraîchir vos compétences en expressions régulières.

</TabItem>

<TabItem value="indice2">

Essayez d'utiliser un site de la liste précédente pour tester l'expression régulière en direct pendant que vous la créez.

</TabItem>

<TabItem value="indice3">

Commencez par essayer de le faire valider chaque format de l'exemple, chacun devrait prendre une nouvelle ligne, une fois que vous les avez tous sélectionnés, puis ajoutez des exemples qui ne doivent pas être sélectionnés et assurez-vous qu'ils ne sont pas sélectionnés.

</TabItem>

<TabItem value="indice4">

Réfléchissez à ce que vous essayez de résoudre étape par étape. Vous trouverez ci-dessous les différents booléens que vous pouvez configurer. Une fois que vous les avez configurés, vous pouvez créer de petits tests regex pour chaque variable.<br />
Cela conduira à une solution beaucoup plus longue que celles contenues dans les spoilers. Cependant, il sera plus facile à déchiffrer et à générer.

```js
// Configurez vos booléens ici
let hasTenDigits = false;
let hasElevenDigits = false;
let startsWithOne = false;
let hasPermittedCharsOnly = false;
let hasCorrectParentheses = false;

/ Écrivez des expressions régulières ici pour que les booléens contiennent les valeurs correctes
// INSÉRER LE CODE AVEC REGEX ICI

// Utilisez les booléens pour renvoyer true ou false, sans avoir à enchaîner une expression régulière complexe
if (!hasTenDigits && !hasElevenDigits) {
  return false;
} else if (!hasPermittedCharsOnly || !hasCorrectParentheses) {
  return false;
} else if (hasElevenDigits && !startsWithOne) {
  return false;
} else {
  return true;
}
```

</TabItem>

</Tabs>

### Solutions

<Tabs
    className="codeTabs"
    defaultValue="solution1"
    values={[
        {label: 'Solution 1', value: 'solution1'},
        {label: 'Solution 2', value: 'solution2'},
    ]}
>
<TabItem value="solution1">

```js
function telephoneCheck(str) {
  var regex = /^(1\s?)?(\(\d{3}\)|\d{3})[\s\-]?\d{3}[\s\-]?\d{4}$/;
  return regex.test(str);
}
telephoneCheck("555-555-5555");
```

#### Explication du code

- `^` désigne le début de la chaîne.
- `(1\s?)?` autorise «1» ou «1» s'il y en a un.
- `\d{n}` recherche exactement n nombre de chiffres, donc `\d{3}` recherche trois chiffres.
- `x|y` vérifie soit x OU y donc `(\(\d{3}\)|\d{3})` vérifie soit trois chiffres entourés de parenthèses, soit trois chiffres seuls sans parenthèses.
- `[\s\-]?` vérifie les espaces ou les tirets entre les groupes de chiffres.
- `$` désigne la fin de la chaîne. Dans ce cas, le début `^` et la fin de la chaîne `$` sont utilisés dans l'expression régulière pour l'empêcher de correspondre à une chaîne plus longue pouvant contenir un numéro de téléphone valide (par exemple «s 555 555 5555 3»).
- Enfin, nous utilisons `regex.test(str)` pour tester si la chaîne adhère à l'expression régulière, elle renvoie `true` ou `false`.

#### Liens pertinents

- [Regex.test()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp/test)
- [Regular Expression Guide](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Expressions_r%C3%A9guli%C3%A8res)


</TabItem>

<TabItem value="solution2">

```js
function telephoneCheck(str) {
  var re = /^([+]?1[\s]?)?((?:[(](?:[2-9]1[02-9]|[2-9][02-8][0-9])[)][\s]?)|(?:(?:[2-9]1[02-9]|[2-9][02-8][0-9])[\s.-]?)){1}([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2}[\s.-]?){1}([0-9]{4}){1}$/;
  return re.test(str);
}
telephoneCheck("555-555-5555");
```

#### Explication du code

Ceci est un exemple de solution très complète et robuste pour valider les numéros de téléphone américains côté client. Dans de tels cas, il pourrait être beaucoup mieux et plus facile d'implémenter cette bibliothèque [libphonenumber](https://github.com/google/libphonenumber).

#### Liens pertinents

- [Regex.test()](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/RegExp/test)
[libphonenumber](https://github.com/google/libphonenumber)

</TabItem>

</Tabs>

:::

-----



## 5. Caisse enregistreuse

[Learn JavaScript Algorithms and Data Structures Projects: Cash Register | freeCodeCamp.org](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/javascript-algorithms-and-data-structures-projects/cash-register)

:::info instructions
Concevez une fonction de tiroir-caisse `checkCashRegister()` qui accepte le prix d'achat comme premier argument (`price`), le paiement comme deuxième argument (`cash`) et cash-in-tiroir (`cid`) comme troisième argument.<br />
`cid` est un tableau 2D répertoriant les devises disponibles.<br />
La fonction `checkCashRegister()` doit toujours renvoyer un objet avec une clé `status` et une clé `change`.<br />
Renvoyez `{status: 'INSUFFICIENT_FUNDS', change: []}` si l'encaisse est inférieure à la monnaie due, ou si vous ne pouvez pas retourner la monnaie exacte.<br />
Renvoyez `{status: 'CLOSED', change: [...]}` avec cash-in-tiroir comme valeur de la clé `change` si elle est égale à la monnaie due.<br />
Sinon, retournez `{status: 'OPEN', change: [...]}`, avec le changement dû en pièces et billets, triés par ordre décroissant, comme valeur de la clé de changement.

| Currency Unit       | Amount             |
| ------------------- | ------------------ |
| Penny               | $0.01 (PENNY)      |
| Nickel              | $0.05 (NICKEL)     |
| Dime                | $0.1 (DIME)        |
| Quarter             | $0.25 (QUARTER)    |
| Dollar              | $1 (ONE)           |
| Five Dollars        | $5 (FIVE)          |
| Ten Dollars         | $10 (TEN)          |
| Twenty Dollars      | $20 (TWENTY)       |
| One-hundred Dollars | $100 (ONE HUNDRED) |

Voir ci-dessous un exemple de tableau de caisse dans un tiroir :

```js
[
  ["PENNY", 1.01],
  ["NICKEL", 2.05],
  ["DIME", 3.1],
  ["QUARTER", 4.25],
  ["ONE", 90],
  ["FIVE", 55],
  ["TEN", 20],
  ["TWENTY", 60],
  ["ONE HUNDRED", 100]
]
```
:::

:::tip missions
- `checkCashRegister(19.5, 20, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.1], ["QUARTER", 4.25], ["ONE", 90], ["FIVE", 55], ["TEN", 20], ["TWENTY", 60], ["ONE HUNDRED", 100]])` devrait renvoyer un objet.
- `checkCashRegister(19.5, 20, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.1], ["QUARTER", 4.25], ["ONE", 90], ["FIVE", 55], ["TEN", 20], ["TWENTY", 60], ["ONE HUNDRED", 100]])` devrait renvoyer `{status: "OPEN", change: [["QUARTER", 0.5]]}`.
- `checkCashRegister(3.26, 100, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.1], ["QUARTER", 4.25], ["ONE", 90], ["FIVE", 55], ["TEN", 20], ["TWENTY", 60], ["ONE HUNDRED", 100]])` devrait renvoyer `{status: "OPEN", change: [["TWENTY", 60], ["TEN", 20], ["FIVE", 15], ["ONE", 1], ["QUARTER", 0.5], ["DIME", 0.2], ["PENNY", 0.04]]}`.
- `checkCashRegister(19.5, 20, [["PENNY", 0.01], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 0], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]])` devrait renvoyer `{status: "INSUFFICIENT_FUNDS", change: []}`.
- `checkCashRegister(19.5, 20, [["PENNY", 0.01], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 1], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]])` devrait renvoyer `{status: "INSUFFICIENT_FUNDS", change: []}`.
- `checkCashRegister(19.5, 20, [["PENNY", 0.5], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 0], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]])` devrait renvoyer `{status: "CLOSED", change: [["PENNY", 0.5], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 0], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]]}`.
:::

<nav class="code-col">
<div class="code-col__item">

```js title="javascript"
let denom = [
  { name: "ONE HUNDRED", val: 100.0 },
  { name: "TWENTY", val: 20.0 },
  { name: "TEN", val: 10.0 },
  { name: "FIVE", val: 5.0 },
  { name: "ONE", val: 1.0 },
  { name: "QUARTER", val: 0.25 },
  { name: "DIME", val: 0.1 },
  { name: "NICKEL", val: 0.05 },
  { name: "PENNY", val: 0.01 }
];

function checkCashRegister(price, cash, cid) {
  let output = { status: null, change: [] };
  let change = cash - price;
  let register = cid.reduce(
    function(acc, curr) {
      acc.total += curr[1];
      acc[curr[0]] = curr[1];
      return acc;
    },
    { total: 0 }
  );
  if (register.total === change) {
    output.status = "CLOSED";
    output.change = cid;
    return output;
  }
  if (register.total < change) {
    output.status = "INSUFFICIENT_FUNDS";
    return output;
  }
  let change_arr = denom.reduce(function(acc, curr) {
    let value = 0;
    while (register[curr.name] > 0 && change >= curr.val) {
      change -= curr.val;
      register[curr.name] -= curr.val;
      value += curr.val;
      change = Math.round(change * 100) / 100;
    }
    if (value > 0) {
      acc.push([curr.name, value]);
    }
    return acc;
  }, []);
  if (change_arr.length < 1 || change > 0) {
    output.status = "INSUFFICIENT_FUNDS";
    return output;
  }
  output.status = "OPEN";
  output.change = change_arr;
  return output;
}

console.log(checkCashRegister(19.5, 20, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.1], ["QUARTER", 4.25], ["ONE", 90], ["FIVE", 55], ["TEN", 20], ["TWENTY", 60], ["ONE HUNDRED", 100]]));
console.log(checkCashRegister(3.26, 100, [["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.1], ["QUARTER", 4.25], ["ONE", 90], ["FIVE", 55], ["TEN", 20], ["TWENTY", 60], ["ONE HUNDRED", 100]]));
console.log(checkCashRegister(19.5, 20, [["PENNY", 0.01], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 0], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]]));
console.log(checkCashRegister(19.5, 20, [["PENNY", 0.01], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 1], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]]));
console.log(checkCashRegister(19.5, 20, [["PENNY", 0.5], ["NICKEL", 0], ["DIME", 0], ["QUARTER", 0], ["ONE", 0], ["FIVE", 0], ["TEN", 0], ["TWENTY", 0], ["ONE HUNDRED", 0]]));
```

</div>
<div class="code-col__item">

```sh title="console"






















































{status: 'OPEN', change: [['QUARTER', 0.5]]}
{status: 'OPEN', change: [['TWENTY', 60], ['TEN', 20], ['FIVE', 15], ['ONE', 1], ['QUARTER', 0.5], ['DIME', 0.2], ['PENNY', 0.04]]}
{status: 'INSUFFICIENT_FUNDS', change: []}
{status: 'INSUFFICIENT_FUNDS', change: []}
{status: 'CLOSED', change: [['PENNY', 0.5], ['NICKEL', 0], ['DIME', 0], ['QUARTER', 0], ['ONE', 0], ['FIVE', 0], ['TEN', 0], ['TWENTY', 0], ['ONE HUNDRED', 0]]}
```

</div></nav>

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-cash-register/16012)

:::note guide : Caisse enregistreuse

#### Explication du problème

- Vous devez créer un programme qui renverra un objet contenant une clé `status` et une clé `change`. La valeur `status` est la chaîne `INSUFFICIENT_FUNDS`, `CLOSED` ou `OPEN`, et la valeur `change` est un tableau 2D du changement dû.

#### Liens pertinents

- [Data Structure Arrays](https://www.freecodecamp.org/news/data-structures-101-arrays-a-visual-introduction-for-beginners-7f013bcc355a/)

### Astuces

<Tabs
    className="codeTabs"
    defaultValue="indice1"
    values={[
        {label: 'Indice 1', value: 'indice1'},
        {label: 'Indice 2', value: 'indice2'},
        {label: 'Indice 3', value: 'indice3'},
    ]}
>
<TabItem value="indice1">

C'est plus facile lorsque vous savez à l'avance combien d'argent se trouve dans votre registre. Pour cela, il est recommandé d'avoir une fonction pour affecter ces informations à une variable. Ensuite, vous pouvez voir si vous avez suffisamment d'argent pour terminer la transaction et retourner la monnaie, ou si vous devez fermer le registre.

</TabItem>

<TabItem value="indice2">

Ce problème est plus facile lorsque vous connaissez la valeur de chaque billet ou pièce de monnaie avec laquelle vous travaillez, plutôt que simplement la somme de chacun dans le registre. Par exemple, il est utile de savoir qu'un nickel vaut 0,05, ainsi que le fait que vous avez 2,05 $ de nickel dans la caisse enregistreuse.

</TabItem>

<TabItem value="indice3">

Vous devrez obtenir autant de monnaie d'un type de billet ou de pièce avant de passer au suivant, d'une valeur supérieure à une valeur moindre. Continuez jusqu'à ce que vous ayez calculé tous les changements dus.

</TabItem>

</Tabs>

### Solutions

<Tabs
    className="codeTabs"
    defaultValue="solution1"
    values={[
        {label: 'Solution 1', value: 'solution1'},
        {label: 'Solution 2', value: 'solution2'},
        {label: 'Solution 3', value: 'solution3'},
    ]}
>
<TabItem value="solution1">


```js
// Crée un tableau d'objets contenant les dénominations et leurs valeurs
var denom = [
  { name: "ONE HUNDRED", val: 100.0 },
  { name: "TWENTY", val: 20.0 },
  { name: "TEN", val: 10.0 },
  { name: "FIVE", val: 5.0 },
  { name: "ONE", val: 1.0 },
  { name: "QUARTER", val: 0.25 },
  { name: "DIME", val: 0.1 },
  { name: "NICKEL", val: 0.05 },
  { name: "PENNY", val: 0.01 }
];

function checkCashRegister(price, cash, cid) {
  var output = { status: null, change: [] };
  var change = cash - price;

  // Transforme le tableau CID en objet tiroir
  var register = cid.reduce(
    function(acc, curr) {
      acc.total += curr[1];
      acc[curr[0]] = curr[1];
      return acc;
    },
    { total: 0 }
  );

  // Gérer le changement exact
  if (register.total === change) {
    output.status = "CLOSED";
    output.change = cid;
    return output;
  }

  // Gérer les fonds manifestement insuffisants
  if (register.total < change) {
    output.status = "INSUFFICIENT_FUNDS";
    return output;
  }

  // Boucle sur le tableau de dénomination
  var change_arr = denom.reduce(function(acc, curr) {
    var value = 0;
    // Tant qu'il y a encore de l'argent de ce type dans le tiroir
    // Et tandis que la dénomination est plus grande que le changement restant
    while (register[curr.name] > 0 && change >= curr.val) {
      change -= curr.val;
      register[curr.name] -= curr.val;
      value += curr.val;

      // Arrondir le changement au centième près traite les erreurs de précision
      change = Math.round(change * 100) / 100;
    }
    // Ajoutez cette dénomination à la sortie uniquement si l'une d'entre elles a été utilisée.
    if (value > 0) {
      acc.push([curr.name, value]);
    }
    return acc; // Renvoie le change_arr actuel
  }, []); // Valeur initiale du tableau vide pour réduire

  // S'il n'y a aucun élément dans change_arr ou s'il reste du changement, retourne
  // la chaîne 'Fonds insuffisants'
  if (change_arr.length < 1 || change > 0) {
    output.status = "INSUFFICIENT_FUNDS";
    return output;
  }

  // Voici votre changement, madame.
  output.status = "OPEN";
  output.change = change_arr;
  return output;
}

// tester ici
checkCashRegister(19.5, 20.0, [
  ["PENNY", 1.01],
  ["NICKEL", 2.05],
  ["DIME", 3.1],
  ["QUARTER", 4.25],
  ["ONE", 90.0],
  ["FIVE", 55.0],
  ["TEN", 20.0],
  ["TWENTY", 60.0],
  ["ONE HUNDRED", 100.0]
]);
```

#### Explication du code

- Commencez par créer un tableau d'objets avec la valeur de chaque dénomination de billet ou de pièce, ainsi qu'un objet de sortie avec les clés de statut et de changement.
- Ensuite, transformez le tableau CID en un objet tiroir.
- Ensuite, gérez les conditions de changement exact et de fonds insuffisants.
- Parcourez le tableau des `denom` et mettez à jour le changement et les valeurs tant qu'il reste de l'argent de chaque type dans le tiroir et que la dénomination est plus grande que la monnaie restante.
- Ajoutez cette dénomination à l'accumulateur de `change_arr` si l'un de ce type a été utilisé.
- Après la boucle, `change_arr` est un tableau 2D du changement dû, trié de la dénomination la plus élevée à la plus petite.
- S'il n'y a aucun élément dans `change_arr` ou si vous devez encore des modifications, renvoyez l'objet de sortie avec un statut `INSUFFICIENT_FUNDS`.
- Enfin, vous pouvez donner le bon changement.
- Renvoyez l'objet de sortie avec un statut `OPEN` et `change_arr` comme valeur de changement.

#### Liens pertinents

- [JS Array Reduce](http://forum.freecodecamp.com/t/javascript-array-prototype-reduce/14299)
- [JS Reduce Made Easy](http://forum.freecodecamp.com/t/using-array-prototype-reduce-to-reduce-conceptual-boilerplate-for-problems-on-arrays/14687)
- [JS Loops](http://forum.freecodecamp.com/t/javascript-loops/14681)
- [JS Array Push](http://forum.freecodecamp.com/t/javascript-array-prototype-push/14298)

</TabItem>

<TabItem value="solution2">

</TabItem>

</Tabs>

:::

-----






:::info instructions
:::

:::tip missions
:::

<nav class="code-col">
<div class="code-col__item">

```js title="javascript"
```

</div>
<div class="code-col__item">

```sh title="console"
```

</div></nav>

[solutions]

:::note guide : 

### Astuces

<Tabs
    className="codeTabs"
    defaultValue="indice1"
    values={[
        {label: 'Indice 1', value: 'indice1'},
        {label: 'Indice 2', value: 'indice2'},
        {label: 'Indice 3', value: 'indice3'},
    ]}
>
<TabItem value="indice1">

</TabItem>

<TabItem value="indice2">

</TabItem>

<TabItem value="indice3">

</TabItem>

</Tabs>


### Solutions

<Tabs
    className="codeTabs"
    defaultValue="solution1"
    values={[
        {label: 'Solution 1', value: 'solution1'},
        {label: 'Solution 2', value: 'solution2'},
        {label: 'Solution 3', value: 'solution3'},
    ]}
>
<TabItem value="solution1">

</TabItem>

<TabItem value="solution2">

</TabItem>

<TabItem value="solution3">

</TabItem>

</Tabs>

:::

-----
