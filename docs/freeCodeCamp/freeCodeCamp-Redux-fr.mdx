---
id: freeCodeCamp-Redux-fr
title: Redux
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Introduction aux défis Redux

[Redux](https://redux.js.org/) est un conteneur d'état prévisible pour les applications JavaScript. Il vous aide à écrire des applications qui se comportent de manière cohérente, s'exécutent dans différents environnements (client, serveur et natif) et sont faciles à tester. Bien que vous puissiez utiliser Redux avec n'importe quelle bibliothèque de vues, il est présenté ici avant d'être combiné avec React.

-----



## 1. Créer un magasin Redux

[Learn Redux: Create a Redux Store | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/create-a-redux-store)

Redux est un cadre de gestion d'état qui peut être utilisé avec un certain nombre de technologies Web différentes, y compris React.<br />
Dans Redux, il existe un objet d'état unique qui est responsable de l'état complet de votre application. Cela signifie que si vous aviez une application React avec dix composants et que chaque composant avait son propre état local, l'état entier de votre application serait défini par un seul objet d'état hébergé dans le `store` Redux. C'est le premier principe important à comprendre lors de l'apprentissage de Redux : le magasin Redux est la seule source de vérité en ce qui concerne l'état des applications.<br />
Cela signifie également que chaque fois qu'un élément de votre application souhaite mettre à jour son état, il doit le faire via le magasin Redux. Le flux de données unidirectionnel facilite le suivi de la gestion de l'état dans votre application.

:::info instructions
Le `store` Redux est un objet qui contient et gère le `state` de l'application. Il existe une méthode appelée `createStore()` sur l'objet Redux, que vous utilisez pour créer le `store` Redux. Cette méthode prend une fonction `reducer` comme argument obligatoire. La fonction de `reducer` est traitée dans un défi ultérieur et est déjà définie pour vous dans l'éditeur de code. Il prend simplement `state` comme argument et renvoie `state`.<br />
Déclarez une variable `store` et affectez-la à la méthode `createStore()`, en passant `reducer` en tant qu'argument.<br />
**Remarque :** Le code de l'éditeur utilise la syntaxe d'argument par défaut ES6 pour initialiser cet état afin qu'il contienne une valeur `5`. Si vous n'êtes pas familier avec les arguments par défaut, vous pouvez vous référer à la [section ES6 du cursus](/docs/freeCodeCamp/freeCodeCamp-ES6-fr#8-d%C3%A9finir-les-param%C3%A8tres-par-d%C3%A9faut-pour-vos-fonctions) qui couvre ce sujet.
:::

:::tip missions
- Le magasin redux doit exister.
- Le magasin redux doit avoir une valeur de 5 pour l'état.
:::


```js title="javascript"
const reducer = (state = 5) => {
  return state;
}

// Les méthodes Redux sont disponibles à partir d'un objet Redux
// Par exemple : Redux.createStore()
// Définissez le magasin ici :

const store = Redux.createStore(reducer);
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-create-a-redux-store/301439)

-----



## 2. Obtenir l'état du magasin Redux

[Learn Redux: Get State from the Redux Store | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/get-state-from-the-redux-store)

L'objet de magasin Redux fournit plusieurs méthodes qui vous permettent d'interagir avec lui. Par exemple, vous pouvez récupérer le `state` actuel contenu dans l'objet de magasin Redux avec la méthode `getState()`.

:::info instructions
Le code du défi précédent est réécrit de manière plus concise dans l'éditeur de code. Utilisez `store.getState()` pour récupérer le `state` du `store` et affectez-le à une nouvelle variable `currentState`.
:::

:::tip missions
- Le magasin redux doit avoir une valeur de 5 pour l'état initial.
- Une variable `currentState` doit exister et doit être affectée à l'état actuel du magasin Redux.
:::

```js title="javascript"
const store = Redux.createStore(
  (state = 5) => state
);

let currentState = store.getState();
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-get-state-from-the-redux-store/301443)

-----



## 3. Définir une action Redux

[Learn Redux: Define a Redux Action | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/define-a-redux-action)

Puisque Redux est un cadre de gestion d'état, la mise à jour de l'état est l'une de ses tâches principales. Dans Redux, toutes les mises à jour d'état sont déclenchées par des actions de distribution. Une action est simplement un objet JavaScript qui contient des informations sur un événement d'action qui s'est produit. Le magasin Redux reçoit ces objets d'action, puis met à jour son état en conséquence. Parfois, une action Redux transporte également des données. Par exemple, l'action porte un nom d'utilisateur après la connexion d'un utilisateur. Bien que les données soient facultatives, les actions doivent porter une propriété `type` qui spécifie le 'type' d'action qui s'est produite.<br />
Considérez les actions Redux comme des messagers qui fournissent des informations sur les événements qui se produisent dans votre application au magasin Redux. Le magasin mène ensuite les activités de mise à jour de l'état en fonction de l'action qui s'est produite.

:::info instructions
Écrire une action Redux est aussi simple que de déclarer un objet avec une propriété type. Déclarez un objet `action` et attribuez-lui une propriété `type` défini sur la chaîne `'LOGIN'`.
:::

:::tip missions
- Un objet action doit exister.
- L'action doit avoir un type de propriété clé avec la valeur `LOGIN`.
:::

```js title="javascript"
let action = {
    type: 'LOGIN'
};
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-define-a-redux-action/301440)

-----



## 4. Définir un créateur d'action

[Learn Redux: Define an Action Creator | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/define-an-action-creator)

Après avoir créé une action, l'étape suivante consiste à envoyer l'action au magasin Redux afin qu'il puisse mettre à jour son état. Dans Redux, vous définissez des créateurs d'action pour accomplir cela. Un créateur d'action est simplement une fonction JavaScript qui renvoie une action. En d'autres termes, les créateurs d'action créent des objets qui représentent des événements d'action.

:::info instructions
Définissez une fonction nommée `actionCreator()` qui renvoie l'objet `action` lorsqu'elle est appelée.
:::

:::tip missions
- La fonction `actionCreator` doit exister.
- L'exécution de la fonction `actionCreator` doit renvoyer l'objet `action`.
- L'action retournée doit avoir un type de propriété clé avec la valeur `LOGIN`.
:::

```js title="javascript"
const action = {
  type: 'LOGIN'
}

function actionCreator() {
  return action;
}
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-define-an-action-creator/301441)

-----



## 5. Distribuer un événement d'action

[Learn Redux: Dispatch an Action Event | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/dispatch-an-action-event)

La méthode `dispatch` est ce que vous utilisez pour envoyer des actions au magasin Redux. L'appel de `store.dispatch()` et la transmission de la valeur renvoyée par un créateur d'action renvoie une action au magasin.<br />
Rappelez-vous que les créateurs d'action renvoient un objet avec une propriété de type qui spécifie l'action qui s'est produite. Ensuite, la méthode distribue un objet d'action au magasin Redux. Sur la base de l'exemple du défi précédent, les lignes suivantes sont équivalentes et distribuent toutes deux l'action de type `LOGIN` :

```js
store.dispatch (actionCreator ());
store.dispatch ({type: 'LOGIN'});
```

:::info instructions
Le magasin Redux dans l'éditeur de code a un état initialisé qui est un objet contenant une propriété `login` actuellement définie sur `false`. Il existe également un créateur d'action appelé `loginAction()` qui renvoie une action de type `LOGIN`. Distribuez l'action `LOGIN` au magasin Redux en appelant la méthode de `dispatch` et transmettez l'action créée par `loginAction()`.
:::

:::tip missions
- L'appel de la fonction `loginAction` doit renvoyer un objet avec la propriété type définie sur la chaîne `LOGIN`.
- Le magasin doit être initialisé avec un objet avec la propriété `login` définie sur `false`.
- La méthode `store.dispatch()` doit être utilisée pour distribuer une action de type `LOGIN`.
:::

```js title="javascript"
const store = Redux.createStore(
  (state = {login: false}) => state
);

const loginAction = () => {
  return {
    type: 'LOGIN'
  }
};

store.dispatch(loginAction());
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-dispatch-an-action-event/301442)

-----



## 6. Gérer une action dans le magasin

[Learn Redux: Handle an Action in the Store | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/handle-an-action-in-the-store)

Une fois qu'une action est créée et distribuée, le magasin Redux doit savoir comment répondre à cette action. C'est le travail d'une fonction `reducer`. Les réducteurs de Redux sont responsables des modifications d'état qui ont lieu en réponse aux actions. Un `reducer` prend `state` et `action` comme arguments, et il renvoie toujours un nouveau `state`. Il est important de voir que c'est le **seul** rôle du réducteur. Il n'a aucun effet secondaire - il n'appelle jamais de point de terminaison d'API et il n'a jamais de surprises cachées. Le réducteur est simplement une fonction pure qui prend un état et une action, puis renvoie un nouvel état.<br />
Un autre principe clé de Redux est que `state` est en lecture seule. En d'autres termes, la fonction de `reducer` doit **toujours** renvoyer une nouvelle copie de `state` et ne jamais modifier l'état directement. Redux n'applique pas l'immuabilité de l'état, cependant, vous êtes responsable de son application dans le code de vos fonctions de réduction. Vous pratiquerez cela dans les défis ultérieurs.

:::info instructions
L'éditeur de code a l'exemple précédent ainsi que le démarrage d'une fonction `reducer` pour vous. Remplissez le corps de la fonction `reducer` afin que, si elle reçoit une action de type `'LOGIN'`, elle renvoie un objet d'état avec `login` défini sur `true`. Sinon, il renvoie le `state` actuel. Notez que le `state` actuel et l'`action` distribuée sont passés au réducteur, vous pouvez donc accéder directement au type d'action avec `action.type`.
:::

:::tip missions
- L'appel de la fonction `loginAction` doit renvoyer un objet avec la propriété type définie sur la chaîne `LOGIN`.
- Le magasin doit être initialisé avec un objet avec la propriété `login` définie sur `false`.
- La distribution de `loginAction` doit mettre à jour la propriété `login` dans l'état du magasin sur `true`.
- Si l'action n'est pas de type `LOGIN`, le magasin doit renvoyer l'état actuel.
:::

```js title="javascript"
const defaultState = {
  login: false
};

const reducer = (state = defaultState, action) => {
  // Change code below this line
  if (action.type === 'LOGIN') {
    return {
      login: true
    };
  } else {
    return state;
  }
  // Change code above this line
};

const store = Redux.createStore(reducer);

const loginAction = () => {
  return {
    type: 'LOGIN'
  }
};
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-handle-an-action-in-the-store/301444)

-----



## 7. Utiliser une instruction `switch` pour gérer plusieurs actions

[Learn Redux: Use a Switch Statement to Handle Multiple Actions | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/use-a-switch-statement-to-handle-multiple-actions)

Vous pouvez indiquer au magasin Redux comment gérer plusieurs types d'action. Supposons que vous gérez l'authentification des utilisateurs dans votre boutique Redux. Vous souhaitez avoir une représentation d'état pour le moment où les utilisateurs sont connectés et lorsqu'ils sont déconnectés. Vous représentez cela avec un objet d'état unique avec la propriété `authenticated`. Vous avez également besoin de créateurs d'action qui créent des actions correspondant à la connexion et à la déconnexion de l'utilisateur, ainsi que les objets d'action eux-mêmes.

:::info instructions
L'éditeur de code a un magasin, des actions et des créateurs d'action mis en place pour vous.
Remplissez la fonction `reducer` pour gérer plusieurs actions d'authentification.
Utilisez une instruction JavaScript `switch` dans le `reducer` pour répondre à différents événements d'action.
Il s'agit d'un modèle standard pour l'écriture de réducteurs Redux.
L'instruction `switch` doit basculer sur `action.type` et renvoyer l'état d'authentification approprié.<br />
**Remarque :** À ce stade, ne vous inquiétez pas de l'immuabilité de l'état, car elle est petite et simple dans cet exemple.
Pour chaque action, vous pouvez renvoyer un nouvel objet - par exemple, `{authenticated: true}`.
N'oubliez pas non plus d'écrire une casse `default` dans votre instruction `switch` qui renvoie le `state` actuel.
Ceci est important car une fois que votre application dispose de plusieurs réducteurs, ils sont tous exécutés chaque fois qu'une distribution d'action est effectuée, même lorsque l'action n'est pas liée à ce réducteur. Dans un tel cas, vous voulez vous assurer que vous renvoyez le `state` actuel.
:::

:::tip missions
- L'appel de la fonction `loginUser` doit renvoyer un objet avec la propriété type définie sur la chaîne `LOGIN`.
- L'appel de la fonction `logoutUser` doit renvoyer un objet avec la propriété type définie sur la chaîne `LOGOUT`.
- Le magasin doit être initialisé avec un objet avec une propriété `authenticated` définie sur `false`.
- La distribution de `loginUser` doit mettre à jour la propriété `authenticated` dans l'état du magasin sur `true`.
- La distribution `logoutUser` doit mettre à jour la propriété `authenticated` dans l'état du magasin sur `false`.
- La fonction `authReducer` doit gérer plusieurs types d'action avec une instruction `switch`.
:::

```js title="javascript"
const defaultState = {
  authenticated: false
};

const authReducer = (state = defaultState, action) => {
  // Change code below this line
  switch(action.type) {
    case 'LOGIN':
      return {
        authenticated: true
      };
    case 'LOGOUT':
      return {
        authenticated: false
      };
    default:
    return defaultState;
  }
  // Change code above this line
};

const store = Redux.createStore(authReducer);

const loginUser = () => {
  return {
    type: 'LOGIN'
  }
};

const logoutUser = () => {
  return {
    type: 'LOGOUT'
  }
};
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-use-a-switch-statement-to-handle-multiple-actions/301449)

-----



## 8. Utiliser `const` pour les types d'action

[Learn Redux: Use const for Action Types | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/use-const-for-action-types)

Une pratique courante lorsque vous travaillez avec Redux consiste à affecter des types d'action en tant que
constantes en lecture seule, puis à référencer ces constantes partout où elles sont utilisées.
Vous pouvez refactoriser le code avec lequel vous travaillez pour écrire les types d'action sous forme de déclarations `const`.

:::info instructions
Déclarez `LOGIN` et `LOGOUT` comme valeurs `const` et affectez-les respectivement aux chaînes `'LOGIN'` et `'LOGOUT'`.
Ensuite, modifiez `authReducer()` et les créateurs d'action pour référencer ces constantes au lieu de valeurs de chaîne.<br />
**Remarque :** c'est généralement une convention d'écrire des constantes en majuscules, et c'est également une pratique standard dans Redux.
:::

:::tip missions
- L'appel de la fonction `loginUser` doit renvoyer un objet avec la propriété `type` définie sur la chaîne `LOGIN`.
- L'appel de la fonction `logoutUser` doit renvoyer un objet avec la propriété `type` définie sur la chaîne `LOGOUT`.
- Le magasin doit être initialisé avec un objet avec la propriété `login` définie sur `false`.
- La distribution de `loginUser` doit mettre à jour la propriété `login` dans l'état du magasin sur `true`.
- La distribution de `logoutUser` doit mettre à jour la propriété `login` dans l'état du magasin sur `false`.
- La fonction `authReducer` doit gérer plusieurs types d'action avec une instruction `switch`.
- `LOGIN` et `LOGOUT` doivent être déclarés en tant que valeurs `const` et doivent se voir attribuer des chaînes `LOGIN` et `LOGOUT`.
- Les créateurs d'action et le réducteur doivent référencer les constantes `LOGIN` et `LOGOUT`.
:::

```js title="javascript"
// Change code below this line
const LOGIN = 'LOGIN';
const LOGOUT = 'LOGOUT';
// Change code above this line

const defaultState = {
  authenticated: false
};

const authReducer = (state = defaultState, action) => {

  switch (action.type) {
    case LOGIN:
      return {
        authenticated: true
      }
    case LOGOUT:
      return {
        authenticated: false
      }
    default:
      return state;
  }
};

const store = Redux.createStore(authReducer);

const loginUser = () => {
  return {
    type: LOGIN
  }
};

const logoutUser = () => {
  return {
    type: LOGOUT
  }
};
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-use-const-for-action-types/301450)

-----



## 9. Enregistrer un auditeur de magasin

[Learn Redux: Register a Store Listener | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/register-a-store-listener)

Une autre méthode à laquelle vous avez accès sur l'objet `store` Redux est `store.subscribe()`.
Cela vous permet d'abonner des fonctions d'écoute au magasin, qui sont appelées chaque fois qu'une action
est distribuée sur le magasin. Une utilisation simple de cette méthode consiste à souscrire une fonction
à votre boutique qui enregistre simplement un message à chaque fois qu'une action est reçue et que la boutique est mise à jour.

:::info instructions
Écrivez une fonction de rappel qui incrémente la variable globale `count` chaque fois que le magasin reçoit une action
et transmettez cette fonction à la méthode `store.subscribe()`. Vous verrez que `store.dispatch()` est appelé trois
fois de suite, chaque fois en passant directement un objet action. Regardez la sortie de la console entre les distributions
d'actions pour voir les mises à jour avoir lieu.
:::

:::tip missions
- La distribution de l'action `ADD` sur le magasin doit incrémenter l'état de `1`.
- Il devrait y avoir une fonction d'écoute abonnée au magasin à l'aide de `store.subscribe`.
- Le rappel de `store.subscribe` doit également incrémenter la variable globale `count` à mesure que le magasin est mis à jour.
:::

<nav class="code-col">
<div class="code-col__item">

```js title="javascript"
const ADD = 'ADD';

const reducer = (state = 0, action) => {
  switch(action.type) {
    case ADD:
      return state + 1;
    default:
      return state;
  }
};

const store = Redux.createStore(reducer);

// Global count variable:
let count = 0;

// Change code below this line
const callBack = () => (count += 1);
store.subscribe(callBack);
// Change code above this line

store.dispatch({type: ADD});
console.log(count);
store.dispatch({type: ADD});
console.log(count);
store.dispatch({type: ADD});
console.log(count);
```

</div>
<div class="code-col__item">

```sh title="console"






















1

2

3
```

</div></nav>

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-register-a-store-listener/301446)

:::note guide : Enregistrer un auditeur de magasin
### Explication du problème
Décomposons les instructions pour comprendre exactement ce qu'elles demandent.

*Écrivez une fonction de rappel qui incrémente le nombre de variables globales chaque fois que le magasin
reçoit une action et transmettez cette fonction à la méthode `store.subscribe()`.*

Nous pouvons résumer ces étapes en petits morceaux :
- écrire une fonction de rappel
- incrémenter le nombre de variables globales
- passer la fonction à la méthode `store.subscribe()`.

Impressionnant ! Passons maintenant en revue quelques-unes des bases.

**Qu'est-ce qu'une “callback function” en anglais simple ?**<br />
Une fonction de rappel est simplement une fonction qui est appelée après qu'une autre fonction est exécutée.
Dans le monde réel, cela pourrait être quelque chose comme ceci :

```js
// Vous déposez votre voiture chez le mécanicien et vous voulez que le magasin vous « rappelle » lorsque votre voiture est réparée.
let carIsBroken = true;
const callCarOwner = () => console.log("Hello your car is done!");
const fixCar = (carIsBroken, callCarOwner) => {
  if (carIsBroken === true) {
    carIsBroken = false;
  }
  console.log(carIsBroken);
// Une fois la voiture réparée, la dernière chose que nous faisons est d'appeler le propriétaire de la voiture - c'est notre « fonction de rappel ».
  callCarOwner();
};
fixCar(carIsBroken, callCarOwner);
```

**Comment augmenter une variable numérique ?**<br />
Nous pouvons le faire en utilisant l'opérateur "+=".

```js
let count = 1;
const addOne = () => (count += 1);
```

**Comment passez-vous une fonction à une méthode ?**<br />
Nous pouvons passer une fonction à une méthode de la même manière que nous pourrions passer une variable à une méthode.
Passez-le simplement comme argument !

```js
function sayHi() {
  console.log("Hi!");
}
store.subscribe(sayHi);
```

:::

-----



## 10. Combinez plusieurs réducteurs

[Learn Redux: Combine Multiple Reducers | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/combine-multiple-reducers)

Lorsque l'état de votre application commence à devenir plus complexe, il peut être tentant de diviser l'état en plusieurs parties.
Au lieu de cela, rappelez-vous le premier principe de Redux : tout l'état de l'application est conservé dans un seul objet d'état
dans le magasin. Par conséquent, Redux fournit une composition de réducteur comme solution pour un modèle d'état complexe.
Vous définissez plusieurs réducteurs pour gérer différentes parties de l'état de votre application, puis composez ces réducteurs
ensemble dans un seul réducteur racine. Le réducteur racine est ensuite passé dans la méthode Redux `createStore()`.<br />
Afin de nous permettre de combiner plusieurs réducteurs ensemble, Redux fournit la méthode `combineReducers()`.
Cette méthode accepte un objet comme argument dans lequel vous définissez des propriétés qui associent des clés à des fonctions
de réduction spécifiques. Le nom que vous donnez aux clés sera utilisé par Redux comme nom de la partie d'état associée.<br />
En règle générale, il est recommandé de créer un réducteur pour chaque élément de l'état de l'application lorsqu'ils sont distincts
ou uniques d'une manière ou d'une autre. Par exemple, dans une application de prise de notes avec authentification de l'utilisateur,
un réducteur peut gérer l'authentification tandis qu'un autre gère le texte et les notes que l'utilisateur soumet.
Pour une telle application, nous pourrions écrire la méthode `combineReducers()` comme ceci :

```js
const rootReducer = Redux.combineReducers({
  auth: authenticationReducer,
  notes: notesReducer
});
```

Désormais, la clé `notes` contiendra tout l'état associé à nos notes et géré par notre `noteReducer`. C'est ainsi que plusieurs
réducteurs peuvent être composés pour gérer des états d'application plus complexes. Dans cet exemple, l'état conservé dans le
magasin Redux serait alors un objet unique contenant les propriétés `auth` et `notes`.

:::info instructions
Il existe des fonctions `counterReducer()` et `authReducer()` fournies dans l'éditeur de code, ainsi qu'un magasin Redux.
Terminez l'écriture de la fonction `rootReducer()` à l'aide de la méthode `Redux.combineReducers()`.
Affectez `counterReducer` à une clé appelée `count` et `authReducer` à une clé appelée `auth`.
:::

:::tip missions
- Le `counterReducer` doit incrémenter et décrémenter `state`.
- Le `authReducer` doit basculer le `state` de `authenticated` entre `true` et `false`.
- Le `state` du magasin doit avoir deux clés : `count`, qui contient un nombre, et `auth`, qui contient un objet. L'objet `auth` doit avoir une propriété `authenticated`, qui contient un booléen.
- Le `rootReducer` doit être une fonction qui combine le `counterReducer` et le `authReducer`.
:::

```js title="javascript"
const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';

const counterReducer = (state = 0, action) => {
  switch(action.type) {
    case INCREMENT:
      return state + 1;
    case DECREMENT:
      return state - 1;
    default:
      return state;
  }
};

const LOGIN = 'LOGIN';
const LOGOUT = 'LOGOUT';

const authReducer = (state = {authenticated: false}, action) => {
  switch(action.type) {
    case LOGIN:
      return {
        authenticated: true
      }
    case LOGOUT:
      return {
        authenticated: false
      }
    default:
      return state;
  }
};

// Define the root reducer here
const rootReducer = Redux.combineReducers({
  auth: authReducer,
  count: counterReducer
});

const store = Redux.createStore(rootReducer);
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-combine-multiple-reducers/301436)

-----



## 11. Envoyer les données d'action au magasin

[Learn Redux: Send Action Data to the Store | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/send-action-data-to-the-store)

Vous avez maintenant appris à distribuer des actions au magasin Redux, mais jusqu'à présent, ces actions n'ont contenu aucune
information autre qu'un `type`. Vous pouvez également envoyer des données spécifiques avec vos actions. En fait, cela est
très courant car les actions proviennent généralement d'une interaction de l'utilisateur et ont tendance à transporter des
données avec elles. Le magasin Redux a souvent besoin de connaître ces données.

:::info instructions
Il y a un créateur d'action `notesReducer()` et `addNoteText()` de base définis dans l'éditeur de code. Terminez le corps
de la fonction `addNoteText()` afin qu'elle renvoie un objet `action`. L'objet doit inclure une propriété `type` avec une valeur
`ADD_NOTE`, ainsi qu'une propriété `text` définie sur les données `note` transmises au créateur d'action. Lorsque vous appelez
le créateur d'action, vous transmettez des informations de note spécifiques auxquelles vous pouvez accéder pour l'objet.<br />
Ensuite, finissez d'écrire l'instruction `switch` dans le `notesReducer()`. Vous devez ajouter un cas qui gère les actions
`addNoteText()`. Ce cas doit être déclenché chaque fois qu'il y a une action de type `ADD_NOTE` et il doit renvoyer la propriété
`text` sur l'`action` entrante comme nouveau `state`.<br />
L'action est distribuée en bas du code. Une fois que vous avez terminé, exécutez le code et regardez la console.
C'est tout ce qu'il faut pour envoyer des données spécifiques à une action au magasin et les utiliser lorsque vous mettez à jour le `state` du magasin.
:::

:::tip missions
- Le créateur d'action `addNoteText` doit renvoyer un objet avec les clés `type` et `text`.
- La distribution d'une action de type `ADD_NOTE` avec le créateur d'action `addNoteText` doit mettre à jour l'état avec la chaîne transmise au créateur d'action.
:::

<nav class="code-col">
<div class="code-col__item">

```js title="javascript"
const ADD_NOTE = 'ADD_NOTE';

const notesReducer = (state = 'Initial State', action) => {
  switch(action.type) {
    // Change code below this line
    case ADD_NOTE:
      return action.text;
    // Change code above this line
    default:
      return state;
  }
};

const addNoteText = (note) => {
  // Change code below this line
  return {
    type: ADD_NOTE,
    text: note
  };
  // Change code above this line
};

const store = Redux.createStore(notesReducer);

console.log(store.getState());
store.dispatch(addNoteText('Hello!'));
console.log(store.getState());
```

</div>
<div class="code-col__item">

```shell title="console"
























Initial State

Hello!
```

</div></nav>

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-send-action-data-to-the-store/301448)

-----



## 12. Utiliser un `middleware` pour gérer les actions asynchrones

[Learn Redux: Use Middleware to Handle Asynchronous Actions | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/use-middleware-to-handle-asynchronous-actions)

Jusqu'à présent, ces défis ont évité de discuter des actions asynchrones, mais ils sont une partie inévitable du
développement Web. À un moment donné, vous devrez appeler des points de terminaison asynchrones dans votre application
Redux, alors comment gérez-vous ces types de demandes ? Redux fournit un middleware spécialement conçu à cet effet,
appelé middleware Redux Thunk. Voici une brève description comment l'utiliser avec Redux.<br />
Pour inclure le middleware Redux Thunk, vous le transmettez comme argument à `Redux.applyMiddleware()`.
Cette instruction est ensuite fournie en tant que deuxième paramètre facultatif à la fonction `createStore ()`.
Jetez un œil au code en bas de l'éditeur pour voir ceci. Ensuite, pour créer une action asynchrone, vous retournez une
fonction dans le créateur d'action qui prend `dispatch` comme argument. Dans cette fonction, vous pouvez distribuer
des actions et effectuer des requêtes asynchrones.<br />
Dans cet exemple, une requête asynchrone est simulée avec un appel `setTimeout()`. Il est courant d'envoyer une action
avant de lancer un comportement asynchrone afin que l'état de votre application sache que certaines données sont demandées
(cet état peut afficher une icône de chargement, par exemple). Ensuite, une fois que vous recevez les données, vous
envoyez une autre action qui transporte les données en tant que charge utile avec des informations indiquant que l'action est terminée.<br />
N'oubliez pas que vous transmettez `dispatch` en tant que paramètre à ce créateur d'action spéciale. C'est ce que vous
utiliserez pour répartir vos actions, vous passez simplement l'action directement à la répartition et le middleware s'occupe du reste.

:::info instructions
Écrivez les deux distributions dans le créateur d'action `handleAsync()`. Distribuez `requestingData()` avant `setTimeout()`
(l'appel d'API simulé). Ensuite, après avoir reçu les données (pretend), envoyez l'action `receiveData()` en transmettant
ces données. Vous savez maintenant comment gérer les actions asynchrones dans Redux. Tout le reste continue de se comporter comme avant.
:::

:::tip missions
- Le créateur d'action `requestingData` doit renvoyer un objet de type égal à la valeur de `REQUESTING_DATA`.
- Le créateur de l'action `receiveData` doit renvoyer un objet de type égal à la valeur de `RECEIVED_DATA`.
- `asyncDataReducer` doit être une fonction.
- La distribution du créateur d'action `requestingData` doit mettre à jour la propriété `state` du magasin de récupération sur `true`.
- La distribution `handleAsync` doit distribuer l'action de demande de données, puis distribuer l'action de données reçues après un délai.
:::

```js title="javascript"
const REQUESTING_DATA = 'REQUESTING_DATA'
const RECEIVED_DATA = 'RECEIVED_DATA'

const requestingData = () => { return {type: REQUESTING_DATA} }
const receivedData = (data) => { return {type: RECEIVED_DATA, users: data.users} }

const handleAsync = () => {
  return function(dispatch) {
    // Dispatch request action here
    dispatch(requestingData());
    setTimeout(function() {
      let data = {
        users: ['Jeff', 'William', 'Alice']
      }
      // Dispatch received data action here
      dispatch(receivedData(data));
    }, 2500);
  }
};

const defaultState = {
  fetching: false,
  users: []
};

const asyncDataReducer = (state = defaultState, action) => {
  switch(action.type) {
    case REQUESTING_DATA:
      return {
        fetching: true,
        users: []
      }
    case RECEIVED_DATA:
      return {
        fetching: false,
        users: action.users
      }
    default:
      return state;
  }
};

const store = Redux.createStore(
  asyncDataReducer,
  Redux.applyMiddleware(ReduxThunk.default)
);
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-use-middleware-to-handle-asynchronous-actions/301451)

-----



## 13. Écrire un compteur avec Redux

[Learn Redux: Write a Counter with Redux | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/write-a-counter-with-redux)

Vous avez maintenant appris tous les principes fondamentaux de Redux ! Vous avez vu comment créer des actions
et des créateurs d'action, créer un magasin Redux, répartir vos actions sur le magasin et concevoir des mises
à jour d'état avec des réducteurs purs. Vous avez même vu comment gérer un état complexe avec la composition
du réducteur et gérer les actions asynchrones. Ces exemples sont simplistes, mais ces concepts sont les principes
fondamentaux de Redux. Si vous les comprenez bien, vous êtes prêt à commencer à créer votre propre application Redux.
Les prochains défis couvrent certains des détails concernant l'immuabilité de `state`, mais d'abord, voici un aperçu
de tout ce que vous avez appris jusqu'à présent.

:::info instructions
Dans cette leçon, vous allez implémenter un compteur simple avec Redux à partir de zéro. Les bases sont fournies dans
l'éditeur de code, mais vous devrez renseigner les détails ! Utilisez les noms fournis et définissez les créateurs
d'actions `incAction` et `decAction`, les types d'actions `counterReducer()`, `INCREMENT` et `DECREMENT`, et enfin
le `store` Redux. Une fois que vous avez terminé, vous devriez être en mesure d'envoyer des actions `INCREMENT` ou
`DECREMENT` pour incrémenter ou décrémenter l'état conservé dans le `store`. Bonne chance pour créer votre première
application Redux !

```js
const INCREMENT = null; // Définir une constante pour les types d'actions d'incrémentation
const DECREMENT = null; // Définir une constante pour les types d'actions de décrémentation
const counterReducer = null; // Définir le réducteur de compteur qui incrémentera ou décrémentera l'état en fonction de l'action qu'il reçoit
const incAction = null; // Définir un créateur d'action pour l'incrémentation
const decAction = null; // Définir un créateur d'action pour décrémenter
const store = null; // Définir ici le magasin Redux en passant vos réducteurs
```

:::

:::tip missions
- Le créateur d'action `incAction` doit renvoyer un objet action avec `type` égal à la valeur `INCREMENT`.
- Le créateur d'action `decAction` doit renvoyer un objet action avec `type` égal à la valeur de `DECREMENT`.
- Le magasin Redux doit s'initialiser avec un `state` de 0.
- La distribution de `incAction` sur le magasin Redux doit incrémenter `state` de 1.
- La distribution de `decAction` sur le magasin Redux doit décrémenter `state` de 1.
- `counterReducer` doit être une fonction.
:::

```js title="javascript"
const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';

const counterReducer = (state = 0, action) => {
  switch(action.type) {
    case INCREMENT:
      return state + 1;
    case DECREMENT:
      return state - 1;
    default:
      return state;
  }
};

const incAction = () => {
  return {
    type: INCREMENT
  };
};

const decAction = () => {
  return {
    type: DECREMENT
  };
};

const store = Redux.createStore(counterReducer);
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-write-a-counter-with-redux/301453)

-----



## 14. Ne jamais muter l'état

[Learn Redux: Never Mutate State | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/never-mutate-state)

Ces derniers défis décrivent plusieurs méthodes d'application du principe clé de l'immuabilité de l'état dans Redux.
L'état immuable signifie que vous ne modifiez jamais l'état directement, à la place, vous retournez une nouvelle copie d'état.<br />
Si vous prenez un instantané de l'état d'une application Redux au fil du temps, vous verrez quelque chose comme
`state 1`, `state 2`, `state 3`, `state 4`... et ainsi de suite où chaque état peut être similaire au dernier,
mais chacun est une donnée distincte. Cette immuabilité, en fait, est ce qui fournit des fonctionnalités telles
que le débogage de voyage dans le temps dont vous avez peut-être entendu parler.<br />
Redux n'applique pas activement l'immuabilité de l'état dans son magasin ou ses réducteurs, cette responsabilité
incombe au programmeur. Heureusement, JavaScript (en particulier ES6) fournit plusieurs outils utiles que vous pouvez
utiliser pour renforcer l'immuabilité de votre état, qu'il s'agisse de `string`, `number`, `array` ou `object`.
Notez que les chaînes et les nombres sont des valeurs primitives et sont immuables par nature. En d'autres termes,
3 est toujours 3. Vous ne pouvez pas modifier la valeur du nombre 3. Cependant, `array` ou `object` sont mutables.
En pratique, votre état sera probablement constitué d'un `array` ou d'un `object`, car ce sont des structures de
données utiles pour représenter de nombreux types d'informations.

:::info instructions
Il y a un `store` et un `reducer` dans l'éditeur de code pour gérer les tâches. Terminez d'écrire le cas `ADD_TO_DO`
dans le réducteur pour ajouter une nouvelle tâche à l'état. Il existe plusieurs façons d'y parvenir avec JavaScript
standard ou ES6. Voyez si vous pouvez trouver un moyen de renvoyer un nouveau tableau avec l'élément de `action.todo`
ajouté à la fin.
:::

:::tip missions
- Le magasin Redux doit exister et s'initialiser avec un état égal au tableau `todos` dans l'éditeur de code.
- `addToDo` et `immutableReducer` doivent tous deux être des fonctions.
- La distribution d'une action de type `ADD_TO_DO` sur le magasin Redux devrait ajouter un élément `todo` et ne devrait PAS muter l'état.
:::

```js title="javascript"
const ADD_TO_DO = 'ADD_TO_DO';

// Une liste de chaînes représentant les tâches à effectuer :
const todos = [
  'Go to the store',
  'Clean the house',
  'Cook dinner',
  'Learn to code',
];

const immutableReducer = (state = todos, action) => {
  switch(action.type) {
    case ADD_TO_DO:
      // Ne pas muter l'état ici ou les tests échoueront
      return state.concat(action.todo);
    default:
      return state;
  }
};

const addToDo = (todo) => {
  return {
    type: ADD_TO_DO,
    todo
  }
}

const store = Redux.createStore(immutableReducer);
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-never-mutate-state/301445)

-----



## 15. Utiliser l'opérateur de propagation `[...]` sur les tableaux

[Learn Redux: Use the Spread Operator on Arrays | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/use-the-spread-operator-on-arrays)

Une solution d'ES6 pour aider à imposer l'immuabilité d'état dans Redux est l'opérateur de propagation : `...`.
L'opérateur de propagation a une variété d'applications, dont l'une est bien adaptée au défi précédent de
produire une nouvelle matrice à partir d'une matrice existante. C'est une syntaxe relativement nouvelle,
mais couramment utilisée. Par exemple, si vous avez un tableau myArray et que vous écrivez :

`let newArray = [...myArray];`

`newArray` est maintenant un clone de `myArray`. Les deux tableaux existent toujours séparément en mémoire.
Si vous effectuez une mutation comme `newArray.push(5)`, `myArray` ne change pas. Le `...` répartit efficacement
les valeurs de `myArray` dans un nouveau tableau. Pour cloner un tableau mais ajouter des valeurs supplémentaires
dans le nouveau tableau, vous pouvez écrire `[...myArray, 'new value']`. Cela renverrait un nouveau tableau
composé des valeurs de `myArray` et de la chaîne `'new value'` comme dernière valeur. La syntaxe de propagation
peut être utilisée plusieurs fois dans une composition de tableau comme celle-ci, mais il est important de noter
qu'elle ne fait qu'une copie superficielle du tableau. Autrement dit, il ne fournit que des opérations de
tableau immuables pour les tableaux à une dimension.

:::info instructions
Utilisez l'opérateur de propagation pour renvoyer une nouvelle copie de l'état lorsqu'une tâche est ajoutée.
:::

:::tip missions
- Le magasin Redux doit exister et s'initialiser avec un état égal à `[Do not mutate state!]`.
- `addToDo` et `immutableReducer` doivent tous deux être des fonctions.
- La distribution d'une action de type `ADD_TO_DO` sur le magasin Redux devrait ajouter un élément `todo` et ne devrait PAS muter l'état.
- L'opérateur de propagation doit être utilisé pour renvoyer un nouvel état.
:::

```js title="javascript"
const immutableReducer = (state = ['Do not mutate state!'], action) => {
  switch(action.type) {
    case 'ADD_TO_DO':
      // Ne pas muter l'état ici ou les tests échoueront
      let arr = [...state, action.todo];
      return arr;
    default:
      return state;
  }
};

const addToDo = (todo) => {
  return {
    type: 'ADD_TO_DO',
    todo
  }
}

const store = Redux.createStore(immutableReducer);
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-use-the-spread-operator-on-arrays/301452)

-----



## 16. Supprimer un élément d'un tableau

[Learn Redux: Remove an Item from an Array | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/remove-an-item-from-an-array)

Il est temps de s'exercer à supprimer des éléments d'un tableau. L'opérateur de propagation peut également être utilisé ici.
D'autres méthodes JavaScript utiles incluent `slice()` et `concat()`.

:::info instructions
Le réducteur et le créateur d'action ont été modifiés pour supprimer un élément d'un tableau en fonction de
l'index de l'élément. Terminez l'écriture du réducteur afin qu'un nouveau tableau d'état soit renvoyé avec
l'élément à l'index spécifique supprimé.
:::

:::tip missions
- Le magasin Redux doit exister et s'initialiser avec un état égal à `[0,1,2,3,4,5]`.
- `removeItem` et `immutableReducer` doivent tous deux être des fonctions.
- La distribution du créateur d'action `removeItem` doit supprimer les éléments de l'état et ne doit PAS muter l'état.
:::

```js title="javascript"
const immutableReducer = (state = [0,1,2,3,4,5], action) => {
  switch(action.type) {
    case 'REMOVE_ITEM':
      // Don't mutate state here or the tests will fail
      return [
        ...state.slice(0, action.index),
        ...state.slice(action.index + 1, state.length)
      ];
      // ou return state.slice(0, action.index).concat(state.slice(action.index + 1, state.length));
    default:
      return state;
  }
};

const removeItem = index => {
  return {
    type: "REMOVE_ITEM",
    index
  };
};

const store = Redux.createStore(immutableReducer);
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-remove-an-item-from-an-array/301447)

:::note guide : Supprimer un élément d'un tableau
### Explication du code
- `array.slice(fromIndex, untilIndex)` renvoie un nouveau tableau
- 1ère partie de l'index du premier élément (0 inclus) jusqu'à `indexToRemove(action.index exclusive)`
- 2ème partie de l'élément juste après `indexToRemove(action.index + 1 inclusive)` jusqu'à la longueur (index du dernier élément + 1 exclusif)
- puisque slice renvoie un nouveau tableau, combinez les deux parties avec l'opérateur de propagation `[...array1,...array2]`
- ou combinez-les avec `.concat()`
:::

-----



## 17. Copier un objet avec `Object.assign`

[Learn Redux: Copy an Object with Object.assign | freeCodeCamp.org](https://www.freecodecamp.org/learn/front-end-libraries/redux/copy-an-object-with-object-assign)

Les derniers défis ont fonctionné avec les tableaux, mais il existe des moyens de renforcer l'immuabilité de
l'état lorsque l'état est également un `object`. L'utilitaire `Object.assign()` est un outil utile pour gérer
les objets. `Object.assign()` prend un objet cible et des objets source et mappe les propriétés des objets
source à l'objet cible. Toutes les propriétés correspondantes sont remplacées par les propriétés des objets
source. Ce comportement est couramment utilisé pour créer des copies superficielles d'objets en passant un
objet vide comme premier argument suivi du ou des objets que vous souhaitez copier. Voici un exemple :

```js
const newObject = Object.assign({}, obj1, obj2);
```

Cela crée `newObject` en tant que nouvel `object`, qui contient les propriétés qui existent actuellement dans `obj1` et `obj2`.

:::info instructions
L'état et les actions de Redux ont été modifiés pour gérer un `object` pour le `state`. Modifiez le code
pour renvoyer un nouveau `state` de l'objet pour les actions de type `ONLINE`, qui définissent la propriété
`status` sur la chaîne `online`. Essayez d'utiliser `Object.assign()` pour terminer le défi.
:::

:::tip missions
- Le magasin Redux doit exister et s'initialiser avec un état équivalent à l'objet `defaultState` déclaré à la ligne 1.
- `wakeUp` et `immutableReducer` doivent tous deux être des fonctions.
- La distribution d'une action de type `ONLINE` doit mettre à jour la propriété `status` dans l'état `online` et ne doit PAS muter l'état.
- `Object.assign` doit être utilisé pour renvoyer un nouvel état.
:::

```js title="javascript"
const defaultState = {
  user: 'CamperBot',
  status: 'offline',
  friends: '732,982',
  community: 'freeCodeCamp'
};

const immutableReducer = (state = defaultState, action) => {
  switch(action.type) {
    case 'ONLINE':
      // Ne pas muter l'état ici ou les tests échoueront
      // pour appliquer l'immuabilité de l'état, retourner un nouvel objet state à l'aide de la méthode Object.assign()
      return Object.assign({}, state, { status: "online" });
    default:
      return state;
  }
};

const wakeUp = () => {
  return {
    type: 'ONLINE'
  }
};

const store = Redux.createStore(immutableReducer);
```

[solutions](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-copy-an-object-with-object-assign/301437)
